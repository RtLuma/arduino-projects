
miniboot.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800100  00800100  00000318  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000002c4  00007800  00007800  00000054  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .stab         000010bc  00000000  00000000  00000318  2**2
                  CONTENTS, READONLY, DEBUGGING
  3 .stabstr      000011b8  00000000  00000000  000013d4  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .comment      00000011  00000000  00000000  0000258c  2**0
                  CONTENTS, READONLY
  5 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000025a0  2**2
                  CONTENTS, READONLY
  6 .debug_info   000005f4  00000000  00000000  000025e0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000005a2  00000000  00000000  00002bd4  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000001a  00000000  00000000  00003176  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000208  00000000  00000000  00003190  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00007800 <__vectors>:
    7800:	33 c0       	rjmp	.+102    	; 0x7868 <__ctors_end>
    7802:	00 00       	nop
    7804:	39 c0       	rjmp	.+114    	; 0x7878 <__bad_interrupt>
    7806:	00 00       	nop
    7808:	37 c0       	rjmp	.+110    	; 0x7878 <__bad_interrupt>
    780a:	00 00       	nop
    780c:	35 c0       	rjmp	.+106    	; 0x7878 <__bad_interrupt>
    780e:	00 00       	nop
    7810:	33 c0       	rjmp	.+102    	; 0x7878 <__bad_interrupt>
    7812:	00 00       	nop
    7814:	31 c0       	rjmp	.+98     	; 0x7878 <__bad_interrupt>
    7816:	00 00       	nop
    7818:	2f c0       	rjmp	.+94     	; 0x7878 <__bad_interrupt>
    781a:	00 00       	nop
    781c:	2d c0       	rjmp	.+90     	; 0x7878 <__bad_interrupt>
    781e:	00 00       	nop
    7820:	2b c0       	rjmp	.+86     	; 0x7878 <__bad_interrupt>
    7822:	00 00       	nop
    7824:	29 c0       	rjmp	.+82     	; 0x7878 <__bad_interrupt>
    7826:	00 00       	nop
    7828:	27 c0       	rjmp	.+78     	; 0x7878 <__bad_interrupt>
    782a:	00 00       	nop
    782c:	25 c0       	rjmp	.+74     	; 0x7878 <__bad_interrupt>
    782e:	00 00       	nop
    7830:	23 c0       	rjmp	.+70     	; 0x7878 <__bad_interrupt>
    7832:	00 00       	nop
    7834:	21 c0       	rjmp	.+66     	; 0x7878 <__bad_interrupt>
    7836:	00 00       	nop
    7838:	1f c0       	rjmp	.+62     	; 0x7878 <__bad_interrupt>
    783a:	00 00       	nop
    783c:	1d c0       	rjmp	.+58     	; 0x7878 <__bad_interrupt>
    783e:	00 00       	nop
    7840:	1b c0       	rjmp	.+54     	; 0x7878 <__bad_interrupt>
    7842:	00 00       	nop
    7844:	19 c0       	rjmp	.+50     	; 0x7878 <__bad_interrupt>
    7846:	00 00       	nop
    7848:	17 c0       	rjmp	.+46     	; 0x7878 <__bad_interrupt>
    784a:	00 00       	nop
    784c:	15 c0       	rjmp	.+42     	; 0x7878 <__bad_interrupt>
    784e:	00 00       	nop
    7850:	13 c0       	rjmp	.+38     	; 0x7878 <__bad_interrupt>
    7852:	00 00       	nop
    7854:	11 c0       	rjmp	.+34     	; 0x7878 <__bad_interrupt>
    7856:	00 00       	nop
    7858:	0f c0       	rjmp	.+30     	; 0x7878 <__bad_interrupt>
    785a:	00 00       	nop
    785c:	0d c0       	rjmp	.+26     	; 0x7878 <__bad_interrupt>
    785e:	00 00       	nop
    7860:	0b c0       	rjmp	.+22     	; 0x7878 <__bad_interrupt>
    7862:	00 00       	nop
    7864:	09 c0       	rjmp	.+18     	; 0x7878 <__bad_interrupt>
	...

00007868 <__ctors_end>:
    7868:	11 24       	eor	r1, r1
    786a:	1f be       	out	0x3f, r1	; 63
    786c:	cf ef       	ldi	r28, 0xFF	; 255
    786e:	d8 e0       	ldi	r29, 0x08	; 8
    7870:	de bf       	out	0x3e, r29	; 62
    7872:	cd bf       	out	0x3d, r28	; 61
    7874:	12 d1       	rcall	.+548    	; 0x7a9a <main>
    7876:	24 c1       	rjmp	.+584    	; 0x7ac0 <_exit>

00007878 <__bad_interrupt>:
    7878:	c3 cf       	rjmp	.-122    	; 0x7800 <__vectors>

0000787a <_Z8i2c_initv>:
#define Prescaler 1
#define TWBR_val ((((F_CPU / F_SCL) / Prescaler) - 16 ) / 2)

void i2c_init(void)
{
	TWBR = (uint8_t)TWBR_val;
    787a:	80 e2       	ldi	r24, 0x20	; 32
    787c:	80 93 b8 00 	sts	0x00B8, r24	; 0x8000b8 <__TEXT_REGION_LENGTH__+0x7e00b8>
    7880:	08 95       	ret

00007882 <_Z9i2c_starth>:
}

uint8_t i2c_start(uint8_t address)
{
	// reset TWI control register
	TWCR = 0;
    7882:	10 92 bc 00 	sts	0x00BC, r1	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
	// transmit START condition 
	TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN);
    7886:	94 ea       	ldi	r25, 0xA4	; 164
    7888:	90 93 bc 00 	sts	0x00BC, r25	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
	// wait for end of transmission
	while( !(TWCR & (1<<TWINT)) );
    788c:	90 91 bc 00 	lds	r25, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    7890:	97 ff       	sbrs	r25, 7
    7892:	fc cf       	rjmp	.-8      	; 0x788c <_Z9i2c_starth+0xa>
	
	// check if the start condition was successfully transmitted
	if((TWSR & 0xF8) != TW_START){ return 1; }
    7894:	90 91 b9 00 	lds	r25, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7e00b9>
    7898:	98 7f       	andi	r25, 0xF8	; 248
    789a:	98 30       	cpi	r25, 0x08	; 8
    789c:	11 f0       	breq	.+4      	; 0x78a2 <_Z9i2c_starth+0x20>
    789e:	81 e0       	ldi	r24, 0x01	; 1
    78a0:	08 95       	ret
	
	// load slave address into data register
	TWDR = address;
    78a2:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
	// start transmission of address
	TWCR = (1<<TWINT) | (1<<TWEN);
    78a6:	84 e8       	ldi	r24, 0x84	; 132
    78a8:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
	// wait for end of transmission
	while( !(TWCR & (1<<TWINT)) );
    78ac:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    78b0:	87 ff       	sbrs	r24, 7
    78b2:	fc cf       	rjmp	.-8      	; 0x78ac <_Z9i2c_starth+0x2a>
	
	// check if the device has acknowledged the READ / WRITE mode
	uint8_t twst = TW_STATUS & 0xF8;
    78b4:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7e00b9>
    78b8:	88 7f       	andi	r24, 0xF8	; 248
	if ( (twst != TW_MT_SLA_ACK) && (twst != TW_MR_SLA_ACK) ) return 1;
    78ba:	88 31       	cpi	r24, 0x18	; 24
    78bc:	11 f0       	breq	.+4      	; 0x78c2 <_Z9i2c_starth+0x40>
    78be:	80 34       	cpi	r24, 0x40	; 64
    78c0:	71 f7       	brne	.-36     	; 0x789e <_Z9i2c_starth+0x1c>
	
	return 0;
    78c2:	80 e0       	ldi	r24, 0x00	; 0
}
    78c4:	08 95       	ret

000078c6 <_Z9i2c_writeh>:

uint8_t i2c_write(uint8_t data)
{
	// load data into data register
	TWDR = data;
    78c6:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
	// start transmission of data
	TWCR = (1<<TWINT) | (1<<TWEN);
    78ca:	84 e8       	ldi	r24, 0x84	; 132
    78cc:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
	// wait for end of transmission
	while( !(TWCR & (1<<TWINT)) );
    78d0:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    78d4:	87 ff       	sbrs	r24, 7
    78d6:	fc cf       	rjmp	.-8      	; 0x78d0 <_Z9i2c_writeh+0xa>
	
	if( (TWSR & 0xF8) != TW_MT_DATA_ACK ){ return 1; }
    78d8:	90 91 b9 00 	lds	r25, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7e00b9>
    78dc:	98 7f       	andi	r25, 0xF8	; 248
    78de:	81 e0       	ldi	r24, 0x01	; 1
    78e0:	98 32       	cpi	r25, 0x28	; 40
    78e2:	09 f4       	brne	.+2      	; 0x78e6 <_Z9i2c_writeh+0x20>
    78e4:	80 e0       	ldi	r24, 0x00	; 0
	
	return 0;
}
    78e6:	08 95       	ret

000078e8 <_Z12i2c_read_ackv>:

uint8_t i2c_read_ack(void)
{
	
	// start TWI module and acknowledge data after reception
	TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWEA); 
    78e8:	84 ec       	ldi	r24, 0xC4	; 196
    78ea:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
	// wait for end of transmission
	while( !(TWCR & (1<<TWINT)) );
    78ee:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    78f2:	87 ff       	sbrs	r24, 7
    78f4:	fc cf       	rjmp	.-8      	; 0x78ee <_Z12i2c_read_ackv+0x6>
	// return received data from TWDR
	return TWDR;
    78f6:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
}
    78fa:	08 95       	ret

000078fc <_Z13i2c_read_nackv>:

uint8_t i2c_read_nack(void)
{
	
	// start receiving without acknowledging reception
	TWCR = (1<<TWINT) | (1<<TWEN);
    78fc:	84 e8       	ldi	r24, 0x84	; 132
    78fe:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
	// wait for end of transmission
	while( !(TWCR & (1<<TWINT)) );
    7902:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    7906:	87 ff       	sbrs	r24, 7
    7908:	fc cf       	rjmp	.-8      	; 0x7902 <_Z13i2c_read_nackv+0x6>
	// return received data from TWDR
	return TWDR;
    790a:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
}
    790e:	08 95       	ret

00007910 <_Z12i2c_transmithPhj>:

uint8_t i2c_transmit(uint8_t address, uint8_t* data, uint16_t length)
{
    7910:	df 92       	push	r13
    7912:	ef 92       	push	r14
    7914:	ff 92       	push	r15
    7916:	0f 93       	push	r16
    7918:	1f 93       	push	r17
    791a:	cf 93       	push	r28
    791c:	df 93       	push	r29
    791e:	d6 2e       	mov	r13, r22
    7920:	07 2f       	mov	r16, r23
	if (i2c_start(address | I2C_WRITE)) return 1;
    7922:	7a 01       	movw	r14, r20
    7924:	ae df       	rcall	.-164    	; 0x7882 <_Z9i2c_starth>
    7926:	18 2f       	mov	r17, r24
    7928:	88 23       	and	r24, r24
    792a:	11 f0       	breq	.+4      	; 0x7930 <_Z12i2c_transmithPhj+0x20>
    792c:	11 e0       	ldi	r17, 0x01	; 1
    792e:	0f c0       	rjmp	.+30     	; 0x794e <_Z12i2c_transmithPhj+0x3e>
    7930:	cd 2d       	mov	r28, r13
    7932:	d0 2f       	mov	r29, r16
    7934:	ec 0e       	add	r14, r28
    7936:	fd 1e       	adc	r15, r29
	
	for (uint16_t i = 0; i < length; i++)
    7938:	ce 15       	cp	r28, r14
    793a:	df 05       	cpc	r29, r15
	{
		if (i2c_write(data[i])) return 1;
    793c:	29 f0       	breq	.+10     	; 0x7948 <_Z12i2c_transmithPhj+0x38>
    793e:	89 91       	ld	r24, Y+
    7940:	c2 df       	rcall	.-124    	; 0x78c6 <_Z9i2c_writeh>
    7942:	88 23       	and	r24, r24
    7944:	c9 f3       	breq	.-14     	; 0x7938 <_Z12i2c_transmithPhj+0x28>
    7946:	f2 cf       	rjmp	.-28     	; 0x792c <_Z12i2c_transmithPhj+0x1c>
}

void i2c_stop(void)
{
	// transmit STOP condition
	TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWSTO);
    7948:	84 e9       	ldi	r24, 0x94	; 148
    794a:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
	}
	
	i2c_stop();
	
	return 0;
}
    794e:	81 2f       	mov	r24, r17
    7950:	df 91       	pop	r29
    7952:	cf 91       	pop	r28
    7954:	1f 91       	pop	r17
    7956:	0f 91       	pop	r16
    7958:	ff 90       	pop	r15
    795a:	ef 90       	pop	r14
    795c:	df 90       	pop	r13
    795e:	08 95       	ret

00007960 <_Z11i2c_receivehPhj>:

uint8_t i2c_receive(uint8_t address, uint8_t* data, uint16_t length)
{
    7960:	af 92       	push	r10
    7962:	bf 92       	push	r11
    7964:	cf 92       	push	r12
    7966:	df 92       	push	r13
    7968:	ff 92       	push	r15
    796a:	0f 93       	push	r16
    796c:	1f 93       	push	r17
    796e:	cf 93       	push	r28
    7970:	df 93       	push	r29
    7972:	6b 01       	movw	r12, r22
	if (i2c_start(address | I2C_READ)) return 1;
    7974:	8a 01       	movw	r16, r20
    7976:	81 60       	ori	r24, 0x01	; 1
    7978:	84 df       	rcall	.-248    	; 0x7882 <_Z9i2c_starth>
    797a:	f8 2e       	mov	r15, r24
    797c:	81 11       	cpse	r24, r1
    797e:	16 c0       	rjmp	.+44     	; 0x79ac <_Z11i2c_receivehPhj+0x4c>
    7980:	56 01       	movw	r10, r12
	
	for (uint16_t i = 0; i < (length-1); i++)
    7982:	e8 01       	movw	r28, r16
    7984:	21 97       	sbiw	r28, 0x01	; 1
    7986:	c5 01       	movw	r24, r10
    7988:	8c 19       	sub	r24, r12
    798a:	9d 09       	sbc	r25, r13
    798c:	8c 17       	cp	r24, r28
    798e:	9d 07       	cpc	r25, r29
	{
		data[i] = i2c_read_ack();
    7990:	28 f4       	brcc	.+10     	; 0x799c <_Z11i2c_receivehPhj+0x3c>
    7992:	aa df       	rcall	.-172    	; 0x78e8 <_Z12i2c_read_ackv>
    7994:	f5 01       	movw	r30, r10
    7996:	81 93       	st	Z+, r24

uint8_t i2c_receive(uint8_t address, uint8_t* data, uint16_t length)
{
	if (i2c_start(address | I2C_READ)) return 1;
	
	for (uint16_t i = 0; i < (length-1); i++)
    7998:	5f 01       	movw	r10, r30
	{
		data[i] = i2c_read_ack();
	}
	data[(length-1)] = i2c_read_nack();
    799a:	f5 cf       	rjmp	.-22     	; 0x7986 <_Z11i2c_receivehPhj+0x26>
    799c:	cc 0d       	add	r28, r12
    799e:	dd 1d       	adc	r29, r13
    79a0:	ad df       	rcall	.-166    	; 0x78fc <_Z13i2c_read_nackv>
    79a2:	88 83       	st	Y, r24
}

void i2c_stop(void)
{
	// transmit STOP condition
	TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWSTO);
    79a4:	84 e9       	ldi	r24, 0x94	; 148
    79a6:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
	}
	data[(length-1)] = i2c_read_nack();
	
	i2c_stop();
	
	return 0;
    79aa:	02 c0       	rjmp	.+4      	; 0x79b0 <_Z11i2c_receivehPhj+0x50>
	return 0;
}

uint8_t i2c_receive(uint8_t address, uint8_t* data, uint16_t length)
{
	if (i2c_start(address | I2C_READ)) return 1;
    79ac:	ff 24       	eor	r15, r15
    79ae:	f3 94       	inc	r15
	data[(length-1)] = i2c_read_nack();
	
	i2c_stop();
	
	return 0;
}
    79b0:	8f 2d       	mov	r24, r15
    79b2:	df 91       	pop	r29
    79b4:	cf 91       	pop	r28
    79b6:	1f 91       	pop	r17
    79b8:	0f 91       	pop	r16
    79ba:	ff 90       	pop	r15
    79bc:	df 90       	pop	r13
    79be:	cf 90       	pop	r12
    79c0:	bf 90       	pop	r11
    79c2:	af 90       	pop	r10
    79c4:	08 95       	ret

000079c6 <_Z12i2c_writeReghhPhj>:

uint8_t i2c_writeReg(uint8_t devaddr, uint8_t regaddr, uint8_t* data, uint16_t length)
{
    79c6:	df 92       	push	r13
    79c8:	ef 92       	push	r14
    79ca:	ff 92       	push	r15
    79cc:	0f 93       	push	r16
    79ce:	1f 93       	push	r17
    79d0:	cf 93       	push	r28
    79d2:	df 93       	push	r29
    79d4:	c6 2f       	mov	r28, r22
    79d6:	d4 2e       	mov	r13, r20
    79d8:	05 2f       	mov	r16, r21
	if (i2c_start(devaddr | 0x00)) return 1;
    79da:	79 01       	movw	r14, r18
    79dc:	52 df       	rcall	.-348    	; 0x7882 <_Z9i2c_starth>
    79de:	18 2f       	mov	r17, r24
    79e0:	88 23       	and	r24, r24
    79e2:	11 f0       	breq	.+4      	; 0x79e8 <_Z12i2c_writeReghhPhj+0x22>
    79e4:	11 e0       	ldi	r17, 0x01	; 1

	i2c_write(regaddr);
    79e6:	11 c0       	rjmp	.+34     	; 0x7a0a <_Z12i2c_writeReghhPhj+0x44>
    79e8:	8c 2f       	mov	r24, r28
    79ea:	6d df       	rcall	.-294    	; 0x78c6 <_Z9i2c_writeh>
    79ec:	cd 2d       	mov	r28, r13
    79ee:	d0 2f       	mov	r29, r16
    79f0:	ec 0e       	add	r14, r28

	for (uint16_t i = 0; i < length; i++)
    79f2:	fd 1e       	adc	r15, r29
    79f4:	ce 15       	cp	r28, r14
    79f6:	df 05       	cpc	r29, r15
	{
		if (i2c_write(data[i])) return 1;
    79f8:	29 f0       	breq	.+10     	; 0x7a04 <_Z12i2c_writeReghhPhj+0x3e>
    79fa:	89 91       	ld	r24, Y+
    79fc:	64 df       	rcall	.-312    	; 0x78c6 <_Z9i2c_writeh>
    79fe:	88 23       	and	r24, r24
    7a00:	c9 f3       	breq	.-14     	; 0x79f4 <_Z12i2c_writeReghhPhj+0x2e>
    7a02:	f0 cf       	rjmp	.-32     	; 0x79e4 <_Z12i2c_writeReghhPhj+0x1e>
}

void i2c_stop(void)
{
	// transmit STOP condition
	TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWSTO);
    7a04:	84 e9       	ldi	r24, 0x94	; 148
    7a06:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
	}

	i2c_stop();

	return 0;
}
    7a0a:	81 2f       	mov	r24, r17
    7a0c:	df 91       	pop	r29
    7a0e:	cf 91       	pop	r28
    7a10:	1f 91       	pop	r17
    7a12:	0f 91       	pop	r16
    7a14:	ff 90       	pop	r15
    7a16:	ef 90       	pop	r14
    7a18:	df 90       	pop	r13
    7a1a:	08 95       	ret

00007a1c <_Z11i2c_readReghhPhj>:

uint8_t i2c_readReg(uint8_t devaddr, uint8_t regaddr, uint8_t* data, uint16_t length)
{
    7a1c:	af 92       	push	r10
    7a1e:	bf 92       	push	r11
    7a20:	cf 92       	push	r12
    7a22:	df 92       	push	r13
    7a24:	ff 92       	push	r15
    7a26:	0f 93       	push	r16
    7a28:	1f 93       	push	r17
    7a2a:	cf 93       	push	r28
    7a2c:	df 93       	push	r29
    7a2e:	c8 2f       	mov	r28, r24
    7a30:	d6 2f       	mov	r29, r22
	if (i2c_start(devaddr)) return 1;
    7a32:	6a 01       	movw	r12, r20
    7a34:	89 01       	movw	r16, r18
    7a36:	25 df       	rcall	.-438    	; 0x7882 <_Z9i2c_starth>
    7a38:	88 23       	and	r24, r24
    7a3a:	19 f0       	breq	.+6      	; 0x7a42 <_Z11i2c_readReghhPhj+0x26>
    7a3c:	ff 24       	eor	r15, r15

	i2c_write(regaddr);
    7a3e:	f3 94       	inc	r15
    7a40:	1d c0       	rjmp	.+58     	; 0x7a7c <_Z11i2c_readReghhPhj+0x60>
    7a42:	8d 2f       	mov	r24, r29

	if (i2c_start(devaddr | 0x01)) return 1;
    7a44:	40 df       	rcall	.-384    	; 0x78c6 <_Z9i2c_writeh>
    7a46:	8c 2f       	mov	r24, r28
    7a48:	81 60       	ori	r24, 0x01	; 1
    7a4a:	1b df       	rcall	.-458    	; 0x7882 <_Z9i2c_starth>
    7a4c:	f8 2e       	mov	r15, r24
    7a4e:	81 11       	cpse	r24, r1
    7a50:	f5 cf       	rjmp	.-22     	; 0x7a3c <_Z11i2c_readReghhPhj+0x20>

	for (uint16_t i = 0; i < (length-1); i++)
    7a52:	56 01       	movw	r10, r12
    7a54:	e8 01       	movw	r28, r16
    7a56:	21 97       	sbiw	r28, 0x01	; 1
    7a58:	c5 01       	movw	r24, r10
    7a5a:	8c 19       	sub	r24, r12
    7a5c:	9d 09       	sbc	r25, r13
    7a5e:	8c 17       	cp	r24, r28
	{
		data[i] = i2c_read_ack();
    7a60:	9d 07       	cpc	r25, r29
    7a62:	28 f4       	brcc	.+10     	; 0x7a6e <_Z11i2c_readReghhPhj+0x52>
    7a64:	41 df       	rcall	.-382    	; 0x78e8 <_Z12i2c_read_ackv>
    7a66:	f5 01       	movw	r30, r10
    7a68:	81 93       	st	Z+, r24

	i2c_write(regaddr);

	if (i2c_start(devaddr | 0x01)) return 1;

	for (uint16_t i = 0; i < (length-1); i++)
    7a6a:	5f 01       	movw	r10, r30
	{
		data[i] = i2c_read_ack();
	}
	data[(length-1)] = i2c_read_nack();
    7a6c:	f5 cf       	rjmp	.-22     	; 0x7a58 <_Z11i2c_readReghhPhj+0x3c>
    7a6e:	cc 0d       	add	r28, r12
    7a70:	dd 1d       	adc	r29, r13
    7a72:	44 df       	rcall	.-376    	; 0x78fc <_Z13i2c_read_nackv>
    7a74:	88 83       	st	Y, r24
}

void i2c_stop(void)
{
	// transmit STOP condition
	TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWSTO);
    7a76:	84 e9       	ldi	r24, 0x94	; 148
    7a78:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
	data[(length-1)] = i2c_read_nack();

	i2c_stop();

	return 0;
}
    7a7c:	8f 2d       	mov	r24, r15
    7a7e:	df 91       	pop	r29
    7a80:	cf 91       	pop	r28
    7a82:	1f 91       	pop	r17
    7a84:	0f 91       	pop	r16
    7a86:	ff 90       	pop	r15
    7a88:	df 90       	pop	r13
    7a8a:	cf 90       	pop	r12
    7a8c:	bf 90       	pop	r11
    7a8e:	af 90       	pop	r10
    7a90:	08 95       	ret

00007a92 <_Z8i2c_stopv>:
    7a92:	84 e9       	ldi	r24, 0x94	; 148
    7a94:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    7a98:	08 95       	ret

00007a9a <main>:
#include <avr/wdt.h>

static inline void initIO() { LED_INIT(); }

static inline void disableWatchdog() {
  wdt_reset();
    7a9a:	a8 95       	wdr
  MCUSR = 0;
    7a9c:	14 be       	out	0x34, r1	; 52
  WDTCSR |= (1 << WDCE) | (1 << WDE);
    7a9e:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__TEXT_REGION_LENGTH__+0x7e0060>
    7aa2:	88 61       	ori	r24, 0x18	; 24
    7aa4:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__TEXT_REGION_LENGTH__+0x7e0060>
  WDTCSR = 0;
    7aa8:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <__TEXT_REGION_LENGTH__+0x7e0060>
  asm("cli");
}

static inline void init() {
  disableWatchdog();
  i2c_init();
    7aac:	f8 94       	cli
    7aae:	e5 de       	rcall	.-566    	; 0x787a <_Z8i2c_initv>

#include "I2C-master-lib/i2c_master.h"
#include "io.h"
#include <avr/wdt.h>

static inline void initIO() { LED_INIT(); }
    7ab0:	2d 98       	cbi	0x05, 5	; 5
    7ab2:	80 e2       	ldi	r24, 0x20	; 32
    7ab4:	84 b9       	out	0x04, r24	; 4
  // uint32_t i2c_application_timestamp;
  uint16_t application_start = 0;

  // if (isReflashNecessary(i2c_application_timestamp) &&
      // isCrcOk(source_i2c_address_for_program)) {
  LED_ON();
    7ab6:	2d 9a       	sbi	0x05, 5	; 5
}

[[ noreturn ]]
static inline void leaveBootloader(uint16_t &application_start) {
  // hold my beer and watch this!
  reinterpret_cast<void (*)(void)>(application_start)();
    7ab8:	e0 e0       	ldi	r30, 0x00	; 0
    7aba:	f0 e0       	ldi	r31, 0x00	; 0
    7abc:	09 95       	icall
    7abe:	ff cf       	rjmp	.-2      	; 0x7abe <main+0x24>

00007ac0 <_exit>:
    7ac0:	f8 94       	cli

00007ac2 <__stop_program>:
    7ac2:	ff cf       	rjmp	.-2      	; 0x7ac2 <__stop_program>
