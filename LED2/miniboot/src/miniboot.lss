
miniboot.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800100  00800100  000006d6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000682  00007800  00007800  00000054  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .stab         0000177c  00000000  00000000  000006d8  2**2
                  CONTENTS, READONLY, DEBUGGING
  3 .stabstr      00001382  00000000  00000000  00001e54  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .comment      00000011  00000000  00000000  000031d6  2**0
                  CONTENTS, READONLY
  5 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000031e8  2**2
                  CONTENTS, READONLY
  6 .debug_info   000005f4  00000000  00000000  00003228  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000005a2  00000000  00000000  0000381c  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000001a  00000000  00000000  00003dbe  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000208  00000000  00000000  00003dd8  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00007800 <__vectors>:
    7800:	33 c0       	rjmp	.+102    	; 0x7868 <__ctors_end>
    7802:	00 00       	nop
    7804:	39 c0       	rjmp	.+114    	; 0x7878 <__bad_interrupt>
    7806:	00 00       	nop
    7808:	37 c0       	rjmp	.+110    	; 0x7878 <__bad_interrupt>
    780a:	00 00       	nop
    780c:	35 c0       	rjmp	.+106    	; 0x7878 <__bad_interrupt>
    780e:	00 00       	nop
    7810:	33 c0       	rjmp	.+102    	; 0x7878 <__bad_interrupt>
    7812:	00 00       	nop
    7814:	31 c0       	rjmp	.+98     	; 0x7878 <__bad_interrupt>
    7816:	00 00       	nop
    7818:	2f c0       	rjmp	.+94     	; 0x7878 <__bad_interrupt>
    781a:	00 00       	nop
    781c:	2d c0       	rjmp	.+90     	; 0x7878 <__bad_interrupt>
    781e:	00 00       	nop
    7820:	2b c0       	rjmp	.+86     	; 0x7878 <__bad_interrupt>
    7822:	00 00       	nop
    7824:	29 c0       	rjmp	.+82     	; 0x7878 <__bad_interrupt>
    7826:	00 00       	nop
    7828:	27 c0       	rjmp	.+78     	; 0x7878 <__bad_interrupt>
    782a:	00 00       	nop
    782c:	25 c0       	rjmp	.+74     	; 0x7878 <__bad_interrupt>
    782e:	00 00       	nop
    7830:	23 c0       	rjmp	.+70     	; 0x7878 <__bad_interrupt>
    7832:	00 00       	nop
    7834:	21 c0       	rjmp	.+66     	; 0x7878 <__bad_interrupt>
    7836:	00 00       	nop
    7838:	1f c0       	rjmp	.+62     	; 0x7878 <__bad_interrupt>
    783a:	00 00       	nop
    783c:	1d c0       	rjmp	.+58     	; 0x7878 <__bad_interrupt>
    783e:	00 00       	nop
    7840:	1b c0       	rjmp	.+54     	; 0x7878 <__bad_interrupt>
    7842:	00 00       	nop
    7844:	19 c0       	rjmp	.+50     	; 0x7878 <__bad_interrupt>
    7846:	00 00       	nop
    7848:	17 c0       	rjmp	.+46     	; 0x7878 <__bad_interrupt>
    784a:	00 00       	nop
    784c:	15 c0       	rjmp	.+42     	; 0x7878 <__bad_interrupt>
    784e:	00 00       	nop
    7850:	13 c0       	rjmp	.+38     	; 0x7878 <__bad_interrupt>
    7852:	00 00       	nop
    7854:	11 c0       	rjmp	.+34     	; 0x7878 <__bad_interrupt>
    7856:	00 00       	nop
    7858:	0f c0       	rjmp	.+30     	; 0x7878 <__bad_interrupt>
    785a:	00 00       	nop
    785c:	0d c0       	rjmp	.+26     	; 0x7878 <__bad_interrupt>
    785e:	00 00       	nop
    7860:	0b c0       	rjmp	.+22     	; 0x7878 <__bad_interrupt>
    7862:	00 00       	nop
    7864:	09 c0       	rjmp	.+18     	; 0x7878 <__bad_interrupt>
	...

00007868 <__ctors_end>:
    7868:	11 24       	eor	r1, r1
    786a:	1f be       	out	0x3f, r1	; 63
    786c:	cf ef       	ldi	r28, 0xFF	; 255
    786e:	d8 e0       	ldi	r29, 0x08	; 8
    7870:	de bf       	out	0x3e, r29	; 62
    7872:	cd bf       	out	0x3d, r28	; 61
    7874:	57 d2       	rcall	.+1198   	; 0x7d24 <main>
    7876:	03 c3       	rjmp	.+1542   	; 0x7e7e <_exit>

00007878 <__bad_interrupt>:
    7878:	c3 cf       	rjmp	.-122    	; 0x7800 <__vectors>

0000787a <_ZL12writeToFlashjPhRj>:
static inline uint16_t getDataLength(const uint8_t i2c_address) {
  return getWordFromSource(i2c_address, application_length_byte_offset);
}

static inline void writeToFlash(const uint16_t address, uint8_t *data,
                                uint16_t &application_start) {
    787a:	cf 93       	push	r28
    787c:	df 93       	push	r29
    787e:	db 01       	movw	r26, r22
    7880:	fa 01       	movw	r30, r20

  if (0 == address && 0 == application_start) {
    7882:	00 97       	sbiw	r24, 0x00	; 0
    7884:	f9 f4       	brne	.+62     	; 0x78c4 <_ZL12writeToFlashjPhRj+0x4a>
    7886:	20 81       	ld	r18, Z
    7888:	31 81       	ldd	r19, Z+1	; 0x01
    788a:	23 2b       	or	r18, r19
    788c:	d9 f4       	brne	.+54     	; 0x78c4 <_ZL12writeToFlashjPhRj+0x4a>
    application_start = static_cast<uint16_t>(data[RESET_VECTOR_ARGUMENT_ADDRESS]) << 8;
    788e:	12 96       	adiw	r26, 0x02	; 2
    7890:	2c 91       	ld	r18, X
    7892:	12 97       	sbiw	r26, 0x02	; 2
    7894:	30 e0       	ldi	r19, 0x00	; 0
    7896:	32 2f       	mov	r19, r18
    7898:	22 27       	eor	r18, r18
    789a:	31 83       	std	Z+1, r19	; 0x01
    789c:	20 83       	st	Z, r18
    application_start |=
        static_cast<uint8_t>(data[RESET_VECTOR_ARGUMENT_ADDRESS + 1]);
    789e:	13 96       	adiw	r26, 0x03	; 3
    78a0:	4c 91       	ld	r20, X
    78a2:	13 97       	sbiw	r26, 0x03	; 3
    78a4:	24 2b       	or	r18, r20
    78a6:	31 83       	std	Z+1, r19	; 0x01
    78a8:	20 83       	st	Z, r18

    data[RESET_VECTOR] = static_cast<uint8_t>(jmp_instruction);
    78aa:	2c e0       	ldi	r18, 0x0C	; 12
    78ac:	2c 93       	st	X, r18
    data[RESET_VECTOR + 1] = static_cast<uint8_t>(jmp_instruction >> 8);
    78ae:	24 e9       	ldi	r18, 0x94	; 148
    78b0:	11 96       	adiw	r26, 0x01	; 1
    78b2:	2c 93       	st	X, r18
    78b4:	11 97       	sbiw	r26, 0x01	; 1

    data[RESET_VECTOR_ARGUMENT_ADDRESS] = static_cast<uint8_t>(
        static_cast<uint16_t>(BOOTLOADER_START_ADDRESS) / 2);
    78b6:	12 96       	adiw	r26, 0x02	; 2
    78b8:	1c 92       	st	X, r1
    78ba:	12 97       	sbiw	r26, 0x02	; 2
    data[RESET_VECTOR_ARGUMENT_ADDRESS + 1] = static_cast<uint8_t>(
        (static_cast<uint16_t>(BOOTLOADER_START_ADDRESS) / 2) >> 8);
    78bc:	2c e3       	ldi	r18, 0x3C	; 60
    78be:	13 96       	adiw	r26, 0x03	; 3
    78c0:	2c 93       	st	X, r18
    78c2:	13 97       	sbiw	r26, 0x03	; 3
  } while (ptr);
  wdt_reset();
}

static inline void erasePage(const uint16_t address) {
  boot_page_erase(address);
    78c4:	23 e0       	ldi	r18, 0x03	; 3
    78c6:	fc 01       	movw	r30, r24
    78c8:	20 93 57 00 	sts	0x0057, r18	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
    78cc:	e8 95       	spm
  boot_spm_busy_wait();
    78ce:	07 b6       	in	r0, 0x37	; 55
    78d0:	00 fc       	sbrc	r0, 0
    78d2:	fd cf       	rjmp	.-6      	; 0x78ce <_ZL12writeToFlashjPhRj+0x54>
    78d4:	40 e0       	ldi	r20, 0x00	; 0
static inline void writeToPageBuffer(const uint16_t address, uint8_t *data) {
  erasePage(address);
  for (uint8_t i = 0; i < SPM_PAGESIZE; i += 2) {
    uint16_t w = *data++;
    w += (*data++) << 8;
    boot_page_fill(address + i, w);
    78d6:	51 e0       	ldi	r21, 0x01	; 1
    78d8:	ec 01       	movw	r28, r24
    78da:	ca 1b       	sub	r28, r26
    78dc:	db 0b       	sbc	r29, r27
}

static inline void writeToPageBuffer(const uint16_t address, uint8_t *data) {
  erasePage(address);
  for (uint8_t i = 0; i < SPM_PAGESIZE; i += 2) {
    uint16_t w = *data++;
    78de:	6c 91       	ld	r22, X
    w += (*data++) << 8;
    boot_page_fill(address + i, w);
    78e0:	fe 01       	movw	r30, r28
    78e2:	ea 0f       	add	r30, r26
    78e4:	fb 1f       	adc	r31, r27
    78e6:	11 96       	adiw	r26, 0x01	; 1
    78e8:	2c 91       	ld	r18, X
    78ea:	11 97       	sbiw	r26, 0x01	; 1
    78ec:	30 e0       	ldi	r19, 0x00	; 0
    78ee:	32 2f       	mov	r19, r18
    78f0:	22 27       	eor	r18, r18
    78f2:	26 0f       	add	r18, r22
    78f4:	31 1d       	adc	r19, r1
    78f6:	09 01       	movw	r0, r18
    78f8:	50 93 57 00 	sts	0x0057, r21	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
    78fc:	e8 95       	spm
    78fe:	11 24       	eor	r1, r1
  boot_spm_busy_wait();
}

static inline void writeToPageBuffer(const uint16_t address, uint8_t *data) {
  erasePage(address);
  for (uint8_t i = 0; i < SPM_PAGESIZE; i += 2) {
    7900:	4e 5f       	subi	r20, 0xFE	; 254
    7902:	12 96       	adiw	r26, 0x02	; 2
    7904:	40 38       	cpi	r20, 0x80	; 128
    7906:	59 f7       	brne	.-42     	; 0x78de <_ZL12writeToFlashjPhRj+0x64>
    boot_page_fill(address + i, w);
  }
}

static inline void writePageBufferToFlash(const uint16_t address) {
  boot_page_write(address);
    7908:	25 e0       	ldi	r18, 0x05	; 5
    790a:	fc 01       	movw	r30, r24
    790c:	20 93 57 00 	sts	0x0057, r18	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
    7910:	e8 95       	spm
  boot_spm_busy_wait();
    7912:	07 b6       	in	r0, 0x37	; 55
    7914:	00 fc       	sbrc	r0, 0
    7916:	fd cf       	rjmp	.-6      	; 0x7912 <_ZL12writeToFlashjPhRj+0x98>
  boot_rww_enable();
    7918:	81 e1       	ldi	r24, 0x11	; 17
    791a:	80 93 57 00 	sts	0x0057, r24	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
    791e:	e8 95       	spm
  }

  writeToPageBuffer(address, data);
  writePageBufferToFlash(address);
}
    7920:	df 91       	pop	r29
    7922:	cf 91       	pop	r28
    7924:	08 95       	ret

00007926 <_ZL8readBytehj.constprop.7>:
#pragma once

#include "I2C-master-lib/i2c_master.h"

static inline uint8_t readByte(const uint8_t source_address,
    7926:	cf 93       	push	r28
    7928:	df 93       	push	r29
    792a:	ec 01       	movw	r28, r24
                               const uint16_t register_address) {
  uint8_t data = 0xFF;
  uint8_t write_source_address = source_address << 1;
  i2c_start(write_source_address);
    792c:	80 ea       	ldi	r24, 0xA0	; 160
  i2c_write(register_address >> 8);
    792e:	ee d0       	rcall	.+476    	; 0x7b0c <_Z9i2c_starth>
  i2c_write(register_address);
    7930:	8d 2f       	mov	r24, r29
    7932:	0e d1       	rcall	.+540    	; 0x7b50 <_Z9i2c_writeh>
  i2c_stop();
    7934:	8c 2f       	mov	r24, r28

  uint8_t read_source_address = write_source_address | 0x01;
  i2c_start(read_source_address);
    7936:	0c d1       	rcall	.+536    	; 0x7b50 <_Z9i2c_writeh>
    7938:	f1 d1       	rcall	.+994    	; 0x7d1c <_Z8i2c_stopv>
    793a:	81 ea       	ldi	r24, 0xA1	; 161
  data = i2c_read_ack();

  return data;
}
    793c:	e7 d0       	rcall	.+462    	; 0x7b0c <_Z9i2c_starth>
    793e:	df 91       	pop	r29
  i2c_write(register_address);
  i2c_stop();

  uint8_t read_source_address = write_source_address | 0x01;
  i2c_start(read_source_address);
  data = i2c_read_ack();
    7940:	cf 91       	pop	r28
    7942:	17 c1       	rjmp	.+558    	; 0x7b72 <_Z12i2c_read_ackv>

00007944 <_ZL17getWordFromSourcehj.constprop.6>:

  return data;
}

static inline uint16_t getWordFromSource(const uint8_t i2c_address,
    7944:	0f 93       	push	r16
    7946:	1f 93       	push	r17
    7948:	cf 93       	push	r28
    794a:	df 93       	push	r29
    794c:	8c 01       	movw	r16, r24
                                         const uint16_t data_address) {
  uint16_t result = static_cast<uint16_t>(readByte(i2c_address, data_address))
    794e:	eb df       	rcall	.-42     	; 0x7926 <_ZL8readBytehj.constprop.7>
                    << 8;
    7950:	c8 2f       	mov	r28, r24
    7952:	d0 e0       	ldi	r29, 0x00	; 0
    7954:	dc 2f       	mov	r29, r28
    7956:	cc 27       	eor	r28, r28
  result |= static_cast<uint16_t>(readByte(i2c_address, data_address + 1));
    7958:	c8 01       	movw	r24, r16
    795a:	01 96       	adiw	r24, 0x01	; 1
    795c:	e4 df       	rcall	.-56     	; 0x7926 <_ZL8readBytehj.constprop.7>
    795e:	9e 01       	movw	r18, r28
  return result;
}
    7960:	28 2b       	or	r18, r24
    7962:	c9 01       	movw	r24, r18
    7964:	df 91       	pop	r29
    7966:	cf 91       	pop	r28
    7968:	1f 91       	pop	r17
    796a:	0f 91       	pop	r16
    796c:	08 95       	ret

0000796e <_ZL7isCrcOkh.constprop.4>:

static inline bool isCrcOk(const uint8_t i2c_address) {
    796e:	3f 92       	push	r3
    7970:	4f 92       	push	r4
    7972:	5f 92       	push	r5
    7974:	6f 92       	push	r6
    7976:	7f 92       	push	r7
    7978:	8f 92       	push	r8
    797a:	9f 92       	push	r9
    797c:	af 92       	push	r10
    797e:	bf 92       	push	r11
    7980:	cf 92       	push	r12
    7982:	df 92       	push	r13
    7984:	ef 92       	push	r14
    7986:	ff 92       	push	r15
    7988:	0f 93       	push	r16
    798a:	1f 93       	push	r17
    798c:	cf 93       	push	r28
    798e:	df 93       	push	r29
    7990:	cd b7       	in	r28, 0x3d	; 61
    7992:	de b7       	in	r29, 0x3e	; 62
    7994:	d4 50       	subi	r29, 0x04	; 4
    7996:	0f b6       	in	r0, 0x3f	; 63
    7998:	f8 94       	cli
    799a:	de bf       	out	0x3e, r29	; 62
    799c:	0f be       	out	0x3f, r0	; 63
static inline uint16_t getDataStartAddressInSource(const uint8_t i2c_address) {
  return application_byte_offset;
}

static inline uint16_t getDataLength(const uint8_t i2c_address) {
  return getWordFromSource(i2c_address, application_length_byte_offset);
    799e:	cd bf       	out	0x3d, r28	; 61
    79a0:	80 e2       	ldi	r24, 0x20	; 32
    79a2:	90 e0       	ldi	r25, 0x00	; 0
    79a4:	cf df       	rcall	.-98     	; 0x7944 <_ZL17getWordFromSourcehj.constprop.6>
    79a6:	7c 01       	movw	r14, r24
    79a8:	fe 01       	movw	r30, r28
    79aa:	31 96       	adiw	r30, 0x01	; 1
    79ac:	40 e0       	ldi	r20, 0x00	; 0
    79ae:	50 e0       	ldi	r21, 0x00	; 0
    79b0:	ba 01       	movw	r22, r20
    79b2:	6f 01       	movw	r12, r30
    79b4:	db 01       	movw	r26, r22
    79b6:	ca 01       	movw	r24, r20
    79b8:	28 e0       	ldi	r18, 0x08	; 8
static constexpr uint32_t polynomial_representation = 0xEDB88320UL;
static constexpr uint16_t crc_table_size = 0x100;

static inline uint32_t crc32_for_byte(uint32_t r) {
  for (uint8_t i = 0; i < 8; ++i) {
    r = (r & 1 ? 0 : polynomial_representation) ^ r >> 1;
    79ba:	80 fd       	sbrc	r24, 0
    79bc:	09 c0       	rjmp	.+18     	; 0x79d0 <_ZL7isCrcOkh.constprop.4+0x62>
    79be:	00 e2       	ldi	r16, 0x20	; 32
    79c0:	80 2e       	mov	r8, r16
    79c2:	03 e8       	ldi	r16, 0x83	; 131
    79c4:	90 2e       	mov	r9, r16
    79c6:	08 eb       	ldi	r16, 0xB8	; 184
    79c8:	a0 2e       	mov	r10, r16
    79ca:	0d ee       	ldi	r16, 0xED	; 237
    79cc:	b0 2e       	mov	r11, r16
    79ce:	03 c0       	rjmp	.+6      	; 0x79d6 <_ZL7isCrcOkh.constprop.4+0x68>
    79d0:	81 2c       	mov	r8, r1
    79d2:	91 2c       	mov	r9, r1
    79d4:	54 01       	movw	r10, r8
    79d6:	b6 95       	lsr	r27
    79d8:	a7 95       	ror	r26
    79da:	97 95       	ror	r25
    79dc:	87 95       	ror	r24
    79de:	88 25       	eor	r24, r8
    79e0:	99 25       	eor	r25, r9
    79e2:	aa 25       	eor	r26, r10
    79e4:	bb 25       	eor	r27, r11
    79e6:	21 50       	subi	r18, 0x01	; 1

static constexpr uint32_t polynomial_representation = 0xEDB88320UL;
static constexpr uint16_t crc_table_size = 0x100;

static inline uint32_t crc32_for_byte(uint32_t r) {
  for (uint8_t i = 0; i < 8; ++i) {
    79e8:	41 f7       	brne	.-48     	; 0x79ba <_ZL7isCrcOkh.constprop.4+0x4c>
  return r ^ (uint32_t)0xFF000000L;
}

static inline void init_table(uint32_t *crc_table) {
  for (uint16_t i = 0; i < crc_table_size; ++i) {
    crc_table[i] = crc32_for_byte(i);
    79ea:	b0 95       	com	r27
    79ec:	81 93       	st	Z+, r24
    79ee:	91 93       	st	Z+, r25
    79f0:	a1 93       	st	Z+, r26
    79f2:	b1 93       	st	Z+, r27
    79f4:	4f 5f       	subi	r20, 0xFF	; 255
    79f6:	5f 4f       	sbci	r21, 0xFF	; 255
    79f8:	6f 4f       	sbci	r22, 0xFF	; 255
    79fa:	7f 4f       	sbci	r23, 0xFF	; 255
  }
  return r ^ (uint32_t)0xFF000000L;
}

static inline void init_table(uint32_t *crc_table) {
  for (uint16_t i = 0; i < crc_table_size; ++i) {
    79fc:	41 15       	cp	r20, r1
    79fe:	21 e0       	ldi	r18, 0x01	; 1
    7a00:	52 07       	cpc	r21, r18
    7a02:	61 05       	cpc	r22, r1
    7a04:	71 05       	cpc	r23, r1
    7a06:	b1 f6       	brne	.-84     	; 0x79b4 <_ZL7isCrcOkh.constprop.4+0x46>
    7a08:	41 2c       	mov	r4, r1
    7a0a:	51 2c       	mov	r5, r1
    7a0c:	32 01       	movw	r6, r4
    7a0e:	00 e0       	ldi	r16, 0x00	; 0
    7a10:	10 e0       	ldi	r17, 0x00	; 0
  uint16_t length = getDataLength(i2c_address);

  uint32_t table[crc_table_size];
  init_table(&table[0]);

  for (uint16_t pos = 0; pos < length + 1;
    7a12:	47 01       	movw	r8, r14
    7a14:	8f ef       	ldi	r24, 0xFF	; 255
    7a16:	88 1a       	sub	r8, r24
    7a18:	98 0a       	sbc	r9, r24
       pos += 2) { // length +1 in case of odd number lengths
    if (pos >= length)
      break;

    uint16_t data = getWordFromSource(i2c_address, pos + start_address);
    if (pos == length - 1)
    7a1a:	57 01       	movw	r10, r14
    7a1c:	91 e0       	ldi	r25, 0x01	; 1
    7a1e:	a9 1a       	sub	r10, r25
    7a20:	b1 08       	sbc	r11, r1
    crc32(reinterpret_cast<const void *>(&to_little_endian[0]), 2, &table[0],
          &crc);

    uint8_t toggle_led_every_x_bytes = 128;
    if (0 == pos % toggle_led_every_x_bytes)
      LED_TOGGLE();
    7a22:	33 24       	eor	r3, r3
  uint16_t length = getDataLength(i2c_address);

  uint32_t table[crc_table_size];
  init_table(&table[0]);

  for (uint16_t pos = 0; pos < length + 1;
    7a24:	33 94       	inc	r3
    7a26:	08 15       	cp	r16, r8
    7a28:	19 05       	cpc	r17, r9
       pos += 2) { // length +1 in case of odd number lengths
    if (pos >= length)
    7a2a:	d8 f5       	brcc	.+118    	; 0x7aa2 <_ZL7isCrcOkh.constprop.4+0x134>
    7a2c:	0e 15       	cp	r16, r14
    7a2e:	1f 05       	cpc	r17, r15
      break;

    uint16_t data = getWordFromSource(i2c_address, pos + start_address);
    7a30:	c0 f5       	brcc	.+112    	; 0x7aa2 <_ZL7isCrcOkh.constprop.4+0x134>
    7a32:	c8 01       	movw	r24, r16
    7a34:	82 96       	adiw	r24, 0x22	; 34
    7a36:	86 df       	rcall	.-244    	; 0x7944 <_ZL17getWordFromSourcehj.constprop.6>
    if (pos == length - 1)
    7a38:	0a 15       	cp	r16, r10
    7a3a:	1b 05       	cpc	r17, r11
    7a3c:	09 f4       	brne	.+2      	; 0x7a40 <_ZL7isCrcOkh.constprop.4+0xd2>
      data &= 0xFF00;
    7a3e:	88 27       	eor	r24, r24
}

static inline void crc32(const void *data, const uint16_t length,
                         const uint32_t *crc_table, uint32_t *crc) {
  for (uint16_t i = 0; i < length; ++i) {
    *crc = crc_table[static_cast<uint8_t>(*crc) ^ ((uint8_t *)data)[i]] ^
    7a40:	94 25       	eor	r25, r4
           *crc >> 8;
    7a42:	45 2c       	mov	r4, r5
    7a44:	56 2c       	mov	r5, r6
    7a46:	67 2c       	mov	r6, r7
    7a48:	77 24       	eor	r7, r7
}

static inline void crc32(const void *data, const uint16_t length,
                         const uint32_t *crc_table, uint32_t *crc) {
  for (uint16_t i = 0; i < length; ++i) {
    *crc = crc_table[static_cast<uint8_t>(*crc) ^ ((uint8_t *)data)[i]] ^
    7a4a:	f6 01       	movw	r30, r12
    7a4c:	24 e0       	ldi	r18, 0x04	; 4
    7a4e:	92 9f       	mul	r25, r18
    7a50:	e0 0d       	add	r30, r0
    7a52:	f1 1d       	adc	r31, r1
    7a54:	11 24       	eor	r1, r1
    7a56:	40 81       	ld	r20, Z
    7a58:	51 81       	ldd	r21, Z+1	; 0x01
    7a5a:	62 81       	ldd	r22, Z+2	; 0x02
    7a5c:	73 81       	ldd	r23, Z+3	; 0x03
    7a5e:	44 26       	eor	r4, r20
    7a60:	55 26       	eor	r5, r21
    7a62:	66 26       	eor	r6, r22
    7a64:	77 26       	eor	r7, r23
    7a66:	84 25       	eor	r24, r4
           *crc >> 8;
    7a68:	45 2c       	mov	r4, r5
    7a6a:	56 2c       	mov	r5, r6
    7a6c:	67 2c       	mov	r6, r7
    7a6e:	77 24       	eor	r7, r7
}

static inline void crc32(const void *data, const uint16_t length,
                         const uint32_t *crc_table, uint32_t *crc) {
  for (uint16_t i = 0; i < length; ++i) {
    *crc = crc_table[static_cast<uint8_t>(*crc) ^ ((uint8_t *)data)[i]] ^
    7a70:	f6 01       	movw	r30, r12
    7a72:	94 e0       	ldi	r25, 0x04	; 4
    7a74:	89 9f       	mul	r24, r25
    7a76:	e0 0d       	add	r30, r0
    7a78:	f1 1d       	adc	r31, r1
    7a7a:	11 24       	eor	r1, r1
    7a7c:	80 81       	ld	r24, Z
    7a7e:	91 81       	ldd	r25, Z+1	; 0x01
    7a80:	a2 81       	ldd	r26, Z+2	; 0x02
    7a82:	b3 81       	ldd	r27, Z+3	; 0x03
    7a84:	48 26       	eor	r4, r24
    7a86:	59 26       	eor	r5, r25
    7a88:	6a 26       	eor	r6, r26
    7a8a:	7b 26       	eor	r7, r27

    crc32(reinterpret_cast<const void *>(&to_little_endian[0]), 2, &table[0],
          &crc);

    uint8_t toggle_led_every_x_bytes = 128;
    if (0 == pos % toggle_led_every_x_bytes)
    7a8c:	c8 01       	movw	r24, r16
    7a8e:	8f 77       	andi	r24, 0x7F	; 127
    7a90:	99 27       	eor	r25, r25
    7a92:	89 2b       	or	r24, r25
      LED_TOGGLE();
    7a94:	19 f4       	brne	.+6      	; 0x7a9c <_ZL7isCrcOkh.constprop.4+0x12e>
    7a96:	85 b1       	in	r24, 0x05	; 5
    7a98:	83 25       	eor	r24, r3
  uint16_t length = getDataLength(i2c_address);

  uint32_t table[crc_table_size];
  init_table(&table[0]);

  for (uint16_t pos = 0; pos < length + 1;
    7a9a:	85 b9       	out	0x05, r24	; 5
    7a9c:	0e 5f       	subi	r16, 0xFE	; 254
    7a9e:	1f 4f       	sbci	r17, 0xFF	; 255
    uint8_t toggle_led_every_x_bytes = 128;
    if (0 == pos % toggle_led_every_x_bytes)
      LED_TOGGLE();
  }

  uint32_t expected_crc = static_cast<uint32_t>(getWordFromSource(
    7aa0:	c2 cf       	rjmp	.-124    	; 0x7a26 <_ZL7isCrcOkh.constprop.4+0xb8>
    7aa2:	8c e1       	ldi	r24, 0x1C	; 28
    7aa4:	90 e0       	ldi	r25, 0x00	; 0
                              i2c_address, application_crc_expected_index))
                          << 16;
    7aa6:	4e df       	rcall	.-356    	; 0x7944 <_ZL17getWordFromSourcehj.constprop.6>
    7aa8:	6c 01       	movw	r12, r24
    7aaa:	e1 2c       	mov	r14, r1
    7aac:	f1 2c       	mov	r15, r1
    7aae:	76 01       	movw	r14, r12
    7ab0:	dd 24       	eor	r13, r13
  expected_crc |= static_cast<uint32_t>(
      getWordFromSource(i2c_address, application_crc_expected_index + 2));
    7ab2:	cc 24       	eor	r12, r12
    7ab4:	8e e1       	ldi	r24, 0x1E	; 30
    7ab6:	90 e0       	ldi	r25, 0x00	; 0
    7ab8:	45 df       	rcall	.-374    	; 0x7944 <_ZL17getWordFromSourcehj.constprop.6>

  if (crc == expected_crc) {
    status = true;
  }
  return status;
    7aba:	a0 e0       	ldi	r26, 0x00	; 0
    7abc:	b0 e0       	ldi	r27, 0x00	; 0
    7abe:	c8 2a       	or	r12, r24
    7ac0:	d9 2a       	or	r13, r25
    7ac2:	ea 2a       	or	r14, r26
    7ac4:	fb 2a       	or	r15, r27
    7ac6:	81 e0       	ldi	r24, 0x01	; 1
    7ac8:	c4 14       	cp	r12, r4
    7aca:	d5 04       	cpc	r13, r5
    7acc:	e6 04       	cpc	r14, r6
    7ace:	f7 04       	cpc	r15, r7
    7ad0:	09 f0       	breq	.+2      	; 0x7ad4 <_ZL7isCrcOkh.constprop.4+0x166>
    7ad2:	80 e0       	ldi	r24, 0x00	; 0
}
    7ad4:	dc 5f       	subi	r29, 0xFC	; 252
    7ad6:	0f b6       	in	r0, 0x3f	; 63
    7ad8:	f8 94       	cli
    7ada:	de bf       	out	0x3e, r29	; 62
    7adc:	0f be       	out	0x3f, r0	; 63
    7ade:	cd bf       	out	0x3d, r28	; 61
    7ae0:	df 91       	pop	r29
    7ae2:	cf 91       	pop	r28
    7ae4:	1f 91       	pop	r17
    7ae6:	0f 91       	pop	r16
    7ae8:	ff 90       	pop	r15
    7aea:	ef 90       	pop	r14
    7aec:	df 90       	pop	r13
    7aee:	cf 90       	pop	r12
    7af0:	bf 90       	pop	r11
    7af2:	af 90       	pop	r10
    7af4:	9f 90       	pop	r9
    7af6:	8f 90       	pop	r8
    7af8:	7f 90       	pop	r7
    7afa:	6f 90       	pop	r6
    7afc:	5f 90       	pop	r5
    7afe:	4f 90       	pop	r4
    7b00:	3f 90       	pop	r3
    7b02:	08 95       	ret

00007b04 <_Z8i2c_initv>:
#define Prescaler 1
#define TWBR_val ((((F_CPU / F_SCL) / Prescaler) - 16 ) / 2)

void i2c_init(void)
{
	TWBR = (uint8_t)TWBR_val;
    7b04:	88 e4       	ldi	r24, 0x48	; 72
    7b06:	80 93 b8 00 	sts	0x00B8, r24	; 0x8000b8 <__TEXT_REGION_LENGTH__+0x7e00b8>
    7b0a:	08 95       	ret

00007b0c <_Z9i2c_starth>:
}

uint8_t i2c_start(uint8_t address)
{
	// reset TWI control register
	TWCR = 0;
    7b0c:	10 92 bc 00 	sts	0x00BC, r1	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
	// transmit START condition 
	TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN);
    7b10:	94 ea       	ldi	r25, 0xA4	; 164
    7b12:	90 93 bc 00 	sts	0x00BC, r25	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
	// wait for end of transmission
	while( !(TWCR & (1<<TWINT)) );
    7b16:	90 91 bc 00 	lds	r25, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    7b1a:	97 ff       	sbrs	r25, 7
    7b1c:	fc cf       	rjmp	.-8      	; 0x7b16 <_Z9i2c_starth+0xa>
	
	// check if the start condition was successfully transmitted
	if((TWSR & 0xF8) != TW_START){ return 1; }
    7b1e:	90 91 b9 00 	lds	r25, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7e00b9>
    7b22:	98 7f       	andi	r25, 0xF8	; 248
    7b24:	98 30       	cpi	r25, 0x08	; 8
    7b26:	11 f0       	breq	.+4      	; 0x7b2c <_Z9i2c_starth+0x20>
    7b28:	81 e0       	ldi	r24, 0x01	; 1
    7b2a:	08 95       	ret
	
	// load slave address into data register
	TWDR = address;
    7b2c:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
	// start transmission of address
	TWCR = (1<<TWINT) | (1<<TWEN);
    7b30:	84 e8       	ldi	r24, 0x84	; 132
    7b32:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
	// wait for end of transmission
	while( !(TWCR & (1<<TWINT)) );
    7b36:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    7b3a:	87 ff       	sbrs	r24, 7
    7b3c:	fc cf       	rjmp	.-8      	; 0x7b36 <_Z9i2c_starth+0x2a>
	
	// check if the device has acknowledged the READ / WRITE mode
	uint8_t twst = TW_STATUS & 0xF8;
    7b3e:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7e00b9>
    7b42:	88 7f       	andi	r24, 0xF8	; 248
	if ( (twst != TW_MT_SLA_ACK) && (twst != TW_MR_SLA_ACK) ) return 1;
    7b44:	88 31       	cpi	r24, 0x18	; 24
    7b46:	11 f0       	breq	.+4      	; 0x7b4c <_Z9i2c_starth+0x40>
    7b48:	80 34       	cpi	r24, 0x40	; 64
    7b4a:	71 f7       	brne	.-36     	; 0x7b28 <_Z9i2c_starth+0x1c>
	
	return 0;
    7b4c:	80 e0       	ldi	r24, 0x00	; 0
}
    7b4e:	08 95       	ret

00007b50 <_Z9i2c_writeh>:

uint8_t i2c_write(uint8_t data)
{
	// load data into data register
	TWDR = data;
    7b50:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
	// start transmission of data
	TWCR = (1<<TWINT) | (1<<TWEN);
    7b54:	84 e8       	ldi	r24, 0x84	; 132
    7b56:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
	// wait for end of transmission
	while( !(TWCR & (1<<TWINT)) );
    7b5a:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    7b5e:	87 ff       	sbrs	r24, 7
    7b60:	fc cf       	rjmp	.-8      	; 0x7b5a <_Z9i2c_writeh+0xa>
	
	if( (TWSR & 0xF8) != TW_MT_DATA_ACK ){ return 1; }
    7b62:	90 91 b9 00 	lds	r25, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7e00b9>
    7b66:	98 7f       	andi	r25, 0xF8	; 248
    7b68:	81 e0       	ldi	r24, 0x01	; 1
    7b6a:	98 32       	cpi	r25, 0x28	; 40
    7b6c:	09 f4       	brne	.+2      	; 0x7b70 <_Z9i2c_writeh+0x20>
    7b6e:	80 e0       	ldi	r24, 0x00	; 0
	
	return 0;
}
    7b70:	08 95       	ret

00007b72 <_Z12i2c_read_ackv>:

uint8_t i2c_read_ack(void)
{
	
	// start TWI module and acknowledge data after reception
	TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWEA); 
    7b72:	84 ec       	ldi	r24, 0xC4	; 196
    7b74:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
	// wait for end of transmission
	while( !(TWCR & (1<<TWINT)) );
    7b78:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    7b7c:	87 ff       	sbrs	r24, 7
    7b7e:	fc cf       	rjmp	.-8      	; 0x7b78 <_Z12i2c_read_ackv+0x6>
	// return received data from TWDR
	return TWDR;
    7b80:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
}
    7b84:	08 95       	ret

00007b86 <_Z13i2c_read_nackv>:

uint8_t i2c_read_nack(void)
{
	
	// start receiving without acknowledging reception
	TWCR = (1<<TWINT) | (1<<TWEN);
    7b86:	84 e8       	ldi	r24, 0x84	; 132
    7b88:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
	// wait for end of transmission
	while( !(TWCR & (1<<TWINT)) );
    7b8c:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    7b90:	87 ff       	sbrs	r24, 7
    7b92:	fc cf       	rjmp	.-8      	; 0x7b8c <_Z13i2c_read_nackv+0x6>
	// return received data from TWDR
	return TWDR;
    7b94:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
}
    7b98:	08 95       	ret

00007b9a <_Z12i2c_transmithPhj>:

uint8_t i2c_transmit(uint8_t address, uint8_t* data, uint16_t length)
{
    7b9a:	df 92       	push	r13
    7b9c:	ef 92       	push	r14
    7b9e:	ff 92       	push	r15
    7ba0:	0f 93       	push	r16
    7ba2:	1f 93       	push	r17
    7ba4:	cf 93       	push	r28
    7ba6:	df 93       	push	r29
    7ba8:	d6 2e       	mov	r13, r22
    7baa:	07 2f       	mov	r16, r23
	if (i2c_start(address | I2C_WRITE)) return 1;
    7bac:	7a 01       	movw	r14, r20
    7bae:	ae df       	rcall	.-164    	; 0x7b0c <_Z9i2c_starth>
    7bb0:	18 2f       	mov	r17, r24
    7bb2:	88 23       	and	r24, r24
    7bb4:	11 f0       	breq	.+4      	; 0x7bba <_Z12i2c_transmithPhj+0x20>
    7bb6:	11 e0       	ldi	r17, 0x01	; 1
    7bb8:	0f c0       	rjmp	.+30     	; 0x7bd8 <_Z12i2c_transmithPhj+0x3e>
    7bba:	cd 2d       	mov	r28, r13
    7bbc:	d0 2f       	mov	r29, r16
    7bbe:	ec 0e       	add	r14, r28
    7bc0:	fd 1e       	adc	r15, r29
	
	for (uint16_t i = 0; i < length; i++)
    7bc2:	ce 15       	cp	r28, r14
    7bc4:	df 05       	cpc	r29, r15
	{
		if (i2c_write(data[i])) return 1;
    7bc6:	29 f0       	breq	.+10     	; 0x7bd2 <_Z12i2c_transmithPhj+0x38>
    7bc8:	89 91       	ld	r24, Y+
    7bca:	c2 df       	rcall	.-124    	; 0x7b50 <_Z9i2c_writeh>
    7bcc:	88 23       	and	r24, r24
    7bce:	c9 f3       	breq	.-14     	; 0x7bc2 <_Z12i2c_transmithPhj+0x28>
    7bd0:	f2 cf       	rjmp	.-28     	; 0x7bb6 <_Z12i2c_transmithPhj+0x1c>
}

void i2c_stop(void)
{
	// transmit STOP condition
	TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWSTO);
    7bd2:	84 e9       	ldi	r24, 0x94	; 148
    7bd4:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
	}
	
	i2c_stop();
	
	return 0;
}
    7bd8:	81 2f       	mov	r24, r17
    7bda:	df 91       	pop	r29
    7bdc:	cf 91       	pop	r28
    7bde:	1f 91       	pop	r17
    7be0:	0f 91       	pop	r16
    7be2:	ff 90       	pop	r15
    7be4:	ef 90       	pop	r14
    7be6:	df 90       	pop	r13
    7be8:	08 95       	ret

00007bea <_Z11i2c_receivehPhj>:

uint8_t i2c_receive(uint8_t address, uint8_t* data, uint16_t length)
{
    7bea:	af 92       	push	r10
    7bec:	bf 92       	push	r11
    7bee:	cf 92       	push	r12
    7bf0:	df 92       	push	r13
    7bf2:	ff 92       	push	r15
    7bf4:	0f 93       	push	r16
    7bf6:	1f 93       	push	r17
    7bf8:	cf 93       	push	r28
    7bfa:	df 93       	push	r29
    7bfc:	6b 01       	movw	r12, r22
	if (i2c_start(address | I2C_READ)) return 1;
    7bfe:	8a 01       	movw	r16, r20
    7c00:	81 60       	ori	r24, 0x01	; 1
    7c02:	84 df       	rcall	.-248    	; 0x7b0c <_Z9i2c_starth>
    7c04:	f8 2e       	mov	r15, r24
    7c06:	81 11       	cpse	r24, r1
    7c08:	16 c0       	rjmp	.+44     	; 0x7c36 <_Z11i2c_receivehPhj+0x4c>
    7c0a:	56 01       	movw	r10, r12
	
	for (uint16_t i = 0; i < (length-1); i++)
    7c0c:	e8 01       	movw	r28, r16
    7c0e:	21 97       	sbiw	r28, 0x01	; 1
    7c10:	c5 01       	movw	r24, r10
    7c12:	8c 19       	sub	r24, r12
    7c14:	9d 09       	sbc	r25, r13
    7c16:	8c 17       	cp	r24, r28
    7c18:	9d 07       	cpc	r25, r29
	{
		data[i] = i2c_read_ack();
    7c1a:	28 f4       	brcc	.+10     	; 0x7c26 <_Z11i2c_receivehPhj+0x3c>
    7c1c:	aa df       	rcall	.-172    	; 0x7b72 <_Z12i2c_read_ackv>
    7c1e:	f5 01       	movw	r30, r10
    7c20:	81 93       	st	Z+, r24

uint8_t i2c_receive(uint8_t address, uint8_t* data, uint16_t length)
{
	if (i2c_start(address | I2C_READ)) return 1;
	
	for (uint16_t i = 0; i < (length-1); i++)
    7c22:	5f 01       	movw	r10, r30
	{
		data[i] = i2c_read_ack();
	}
	data[(length-1)] = i2c_read_nack();
    7c24:	f5 cf       	rjmp	.-22     	; 0x7c10 <_Z11i2c_receivehPhj+0x26>
    7c26:	cc 0d       	add	r28, r12
    7c28:	dd 1d       	adc	r29, r13
    7c2a:	ad df       	rcall	.-166    	; 0x7b86 <_Z13i2c_read_nackv>
    7c2c:	88 83       	st	Y, r24
}

void i2c_stop(void)
{
	// transmit STOP condition
	TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWSTO);
    7c2e:	84 e9       	ldi	r24, 0x94	; 148
    7c30:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
	}
	data[(length-1)] = i2c_read_nack();
	
	i2c_stop();
	
	return 0;
    7c34:	02 c0       	rjmp	.+4      	; 0x7c3a <_Z11i2c_receivehPhj+0x50>
	return 0;
}

uint8_t i2c_receive(uint8_t address, uint8_t* data, uint16_t length)
{
	if (i2c_start(address | I2C_READ)) return 1;
    7c36:	ff 24       	eor	r15, r15
    7c38:	f3 94       	inc	r15
	data[(length-1)] = i2c_read_nack();
	
	i2c_stop();
	
	return 0;
}
    7c3a:	8f 2d       	mov	r24, r15
    7c3c:	df 91       	pop	r29
    7c3e:	cf 91       	pop	r28
    7c40:	1f 91       	pop	r17
    7c42:	0f 91       	pop	r16
    7c44:	ff 90       	pop	r15
    7c46:	df 90       	pop	r13
    7c48:	cf 90       	pop	r12
    7c4a:	bf 90       	pop	r11
    7c4c:	af 90       	pop	r10
    7c4e:	08 95       	ret

00007c50 <_Z12i2c_writeReghhPhj>:

uint8_t i2c_writeReg(uint8_t devaddr, uint8_t regaddr, uint8_t* data, uint16_t length)
{
    7c50:	df 92       	push	r13
    7c52:	ef 92       	push	r14
    7c54:	ff 92       	push	r15
    7c56:	0f 93       	push	r16
    7c58:	1f 93       	push	r17
    7c5a:	cf 93       	push	r28
    7c5c:	df 93       	push	r29
    7c5e:	c6 2f       	mov	r28, r22
    7c60:	d4 2e       	mov	r13, r20
    7c62:	05 2f       	mov	r16, r21
	if (i2c_start(devaddr | 0x00)) return 1;
    7c64:	79 01       	movw	r14, r18
    7c66:	52 df       	rcall	.-348    	; 0x7b0c <_Z9i2c_starth>
    7c68:	18 2f       	mov	r17, r24
    7c6a:	88 23       	and	r24, r24
    7c6c:	11 f0       	breq	.+4      	; 0x7c72 <_Z12i2c_writeReghhPhj+0x22>
    7c6e:	11 e0       	ldi	r17, 0x01	; 1

	i2c_write(regaddr);
    7c70:	11 c0       	rjmp	.+34     	; 0x7c94 <_Z12i2c_writeReghhPhj+0x44>
    7c72:	8c 2f       	mov	r24, r28
    7c74:	6d df       	rcall	.-294    	; 0x7b50 <_Z9i2c_writeh>
    7c76:	cd 2d       	mov	r28, r13
    7c78:	d0 2f       	mov	r29, r16
    7c7a:	ec 0e       	add	r14, r28

	for (uint16_t i = 0; i < length; i++)
    7c7c:	fd 1e       	adc	r15, r29
    7c7e:	ce 15       	cp	r28, r14
    7c80:	df 05       	cpc	r29, r15
	{
		if (i2c_write(data[i])) return 1;
    7c82:	29 f0       	breq	.+10     	; 0x7c8e <_Z12i2c_writeReghhPhj+0x3e>
    7c84:	89 91       	ld	r24, Y+
    7c86:	64 df       	rcall	.-312    	; 0x7b50 <_Z9i2c_writeh>
    7c88:	88 23       	and	r24, r24
    7c8a:	c9 f3       	breq	.-14     	; 0x7c7e <_Z12i2c_writeReghhPhj+0x2e>
    7c8c:	f0 cf       	rjmp	.-32     	; 0x7c6e <_Z12i2c_writeReghhPhj+0x1e>
}

void i2c_stop(void)
{
	// transmit STOP condition
	TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWSTO);
    7c8e:	84 e9       	ldi	r24, 0x94	; 148
    7c90:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
	}

	i2c_stop();

	return 0;
}
    7c94:	81 2f       	mov	r24, r17
    7c96:	df 91       	pop	r29
    7c98:	cf 91       	pop	r28
    7c9a:	1f 91       	pop	r17
    7c9c:	0f 91       	pop	r16
    7c9e:	ff 90       	pop	r15
    7ca0:	ef 90       	pop	r14
    7ca2:	df 90       	pop	r13
    7ca4:	08 95       	ret

00007ca6 <_Z11i2c_readReghhPhj>:

uint8_t i2c_readReg(uint8_t devaddr, uint8_t regaddr, uint8_t* data, uint16_t length)
{
    7ca6:	af 92       	push	r10
    7ca8:	bf 92       	push	r11
    7caa:	cf 92       	push	r12
    7cac:	df 92       	push	r13
    7cae:	ff 92       	push	r15
    7cb0:	0f 93       	push	r16
    7cb2:	1f 93       	push	r17
    7cb4:	cf 93       	push	r28
    7cb6:	df 93       	push	r29
    7cb8:	c8 2f       	mov	r28, r24
    7cba:	d6 2f       	mov	r29, r22
	if (i2c_start(devaddr)) return 1;
    7cbc:	6a 01       	movw	r12, r20
    7cbe:	89 01       	movw	r16, r18
    7cc0:	25 df       	rcall	.-438    	; 0x7b0c <_Z9i2c_starth>
    7cc2:	88 23       	and	r24, r24
    7cc4:	19 f0       	breq	.+6      	; 0x7ccc <_Z11i2c_readReghhPhj+0x26>
    7cc6:	ff 24       	eor	r15, r15

	i2c_write(regaddr);
    7cc8:	f3 94       	inc	r15
    7cca:	1d c0       	rjmp	.+58     	; 0x7d06 <_Z11i2c_readReghhPhj+0x60>
    7ccc:	8d 2f       	mov	r24, r29

	if (i2c_start(devaddr | 0x01)) return 1;
    7cce:	40 df       	rcall	.-384    	; 0x7b50 <_Z9i2c_writeh>
    7cd0:	8c 2f       	mov	r24, r28
    7cd2:	81 60       	ori	r24, 0x01	; 1
    7cd4:	1b df       	rcall	.-458    	; 0x7b0c <_Z9i2c_starth>
    7cd6:	f8 2e       	mov	r15, r24
    7cd8:	81 11       	cpse	r24, r1
    7cda:	f5 cf       	rjmp	.-22     	; 0x7cc6 <_Z11i2c_readReghhPhj+0x20>

	for (uint16_t i = 0; i < (length-1); i++)
    7cdc:	56 01       	movw	r10, r12
    7cde:	e8 01       	movw	r28, r16
    7ce0:	21 97       	sbiw	r28, 0x01	; 1
    7ce2:	c5 01       	movw	r24, r10
    7ce4:	8c 19       	sub	r24, r12
    7ce6:	9d 09       	sbc	r25, r13
    7ce8:	8c 17       	cp	r24, r28
	{
		data[i] = i2c_read_ack();
    7cea:	9d 07       	cpc	r25, r29
    7cec:	28 f4       	brcc	.+10     	; 0x7cf8 <_Z11i2c_readReghhPhj+0x52>
    7cee:	41 df       	rcall	.-382    	; 0x7b72 <_Z12i2c_read_ackv>
    7cf0:	f5 01       	movw	r30, r10
    7cf2:	81 93       	st	Z+, r24

	i2c_write(regaddr);

	if (i2c_start(devaddr | 0x01)) return 1;

	for (uint16_t i = 0; i < (length-1); i++)
    7cf4:	5f 01       	movw	r10, r30
	{
		data[i] = i2c_read_ack();
	}
	data[(length-1)] = i2c_read_nack();
    7cf6:	f5 cf       	rjmp	.-22     	; 0x7ce2 <_Z11i2c_readReghhPhj+0x3c>
    7cf8:	cc 0d       	add	r28, r12
    7cfa:	dd 1d       	adc	r29, r13
    7cfc:	44 df       	rcall	.-376    	; 0x7b86 <_Z13i2c_read_nackv>
    7cfe:	88 83       	st	Y, r24
}

void i2c_stop(void)
{
	// transmit STOP condition
	TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWSTO);
    7d00:	84 e9       	ldi	r24, 0x94	; 148
    7d02:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
	data[(length-1)] = i2c_read_nack();

	i2c_stop();

	return 0;
}
    7d06:	8f 2d       	mov	r24, r15
    7d08:	df 91       	pop	r29
    7d0a:	cf 91       	pop	r28
    7d0c:	1f 91       	pop	r17
    7d0e:	0f 91       	pop	r16
    7d10:	ff 90       	pop	r15
    7d12:	df 90       	pop	r13
    7d14:	cf 90       	pop	r12
    7d16:	bf 90       	pop	r11
    7d18:	af 90       	pop	r10
    7d1a:	08 95       	ret

00007d1c <_Z8i2c_stopv>:
    7d1c:	84 e9       	ldi	r24, 0x94	; 148
    7d1e:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    7d22:	08 95       	ret

00007d24 <main>:
// TODO: Don't reflash everytime

  return true;
}

int main() {
    7d24:	cf 93       	push	r28
    7d26:	df 93       	push	r29
    7d28:	cd b7       	in	r28, 0x3d	; 61
    7d2a:	de b7       	in	r29, 0x3e	; 62
    7d2c:	c2 58       	subi	r28, 0x82	; 130
    7d2e:	d1 09       	sbc	r29, r1
    7d30:	0f b6       	in	r0, 0x3f	; 63
    7d32:	f8 94       	cli
    7d34:	de bf       	out	0x3e, r29	; 62
    7d36:	0f be       	out	0x3f, r0	; 63

static inline uint16_t getDataLength(const uint8_t i2c_address) {
  return getWordFromSource(i2c_address, application_length_byte_offset);
}

static inline void writeToFlash(const uint16_t address, uint8_t *data,
    7d38:	cd bf       	out	0x3d, r28	; 61
    7d3a:	e4 de       	rcall	.-568    	; 0x7b04 <_Z8i2c_initv>
//  Fuses :     Ext: 0xFF, Hi: 0xD8, Lo: 0xE2
//

#include "crc32.h"
#include "bootloader.h"
#include "flash.h"
    7d3c:	28 9a       	sbi	0x05, 0	; 5
    7d3e:	81 e0       	ldi	r24, 0x01	; 1
    7d40:	84 b9       	out	0x04, r24	; 4
int main() {

  init();

  uint32_t i2c_application_timestamp;
  uint16_t application_start = 0;
    7d42:	cf 57       	subi	r28, 0x7F	; 127
    7d44:	df 4f       	sbci	r29, 0xFF	; 255
    7d46:	19 82       	std	Y+1, r1	; 0x01
    7d48:	18 82       	st	Y, r1
    7d4a:	c1 58       	subi	r28, 0x81	; 129

  if (isReflashNecessary(i2c_application_timestamp) &&
      isCrcOk(source_i2c_address_for_program)) {
    7d4c:	d0 40       	sbci	r29, 0x00	; 0
    7d4e:	0f de       	rcall	.-994    	; 0x796e <_ZL7isCrcOkh.constprop.4>
  init();

  uint32_t i2c_application_timestamp;
  uint16_t application_start = 0;

  if (isReflashNecessary(i2c_application_timestamp) &&
    7d50:	88 23       	and	r24, r24
    7d52:	09 f4       	brne	.+2      	; 0x7d56 <main+0x32>
    7d54:	73 c0       	rjmp	.+230    	; 0x7e3c <main+0x118>
    7d56:	e0 e0       	ldi	r30, 0x00	; 0
    7d58:	f8 e7       	ldi	r31, 0x78	; 120

static inline void eraseApplication() {
  uint16_t ptr = BOOTLOADER_START_ADDRESS;
  do {
    ptr -= SPM_PAGESIZE;
    boot_page_erase(ptr);
    7d5a:	83 e0       	ldi	r24, 0x03	; 3
#include "bootloader.h"

static inline void eraseApplication() {
  uint16_t ptr = BOOTLOADER_START_ADDRESS;
  do {
    ptr -= SPM_PAGESIZE;
    7d5c:	e0 58       	subi	r30, 0x80	; 128
    7d5e:	f1 09       	sbc	r31, r1
    boot_page_erase(ptr);
    7d60:	80 93 57 00 	sts	0x0057, r24	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
    7d64:	e8 95       	spm
    boot_spm_busy_wait();
    7d66:	07 b6       	in	r0, 0x37	; 55
    7d68:	00 fc       	sbrc	r0, 0
    7d6a:	fd cf       	rjmp	.-6      	; 0x7d66 <main+0x42>

#include "bootloader.h"

static inline void eraseApplication() {
  uint16_t ptr = BOOTLOADER_START_ADDRESS;
  do {
    7d6c:	30 97       	sbiw	r30, 0x00	; 0
    7d6e:	b1 f7       	brne	.-20     	; 0x7d5c <main+0x38>
    ptr -= SPM_PAGESIZE;
    boot_page_erase(ptr);
    boot_spm_busy_wait();
  } while (ptr);
  wdt_reset();
}
    7d70:	a8 95       	wdr
    7d72:	80 e2       	ldi	r24, 0x20	; 32
    7d74:	90 e0       	ldi	r25, 0x00	; 0
    7d76:	e6 dd       	rcall	.-1076   	; 0x7944 <_ZL17getWordFromSourcehj.constprop.6>
    7d78:	6c 01       	movw	r12, r24
    7d7a:	a1 2c       	mov	r10, r1
    7d7c:	b1 2c       	mov	r11, r1
    7d7e:	00 e0       	ldi	r16, 0x00	; 0
    7d80:	10 e0       	ldi	r17, 0x00	; 0
    7d82:	ce 01       	movw	r24, r28
    7d84:	01 96       	adiw	r24, 0x01	; 1
    7d86:	7c 01       	movw	r14, r24
    7d88:	77 24       	eor	r7, r7
    7d8a:	73 94       	inc	r7
    7d8c:	ac 14       	cp	r10, r12
    7d8e:	bd 04       	cpc	r11, r13
    7d90:	60 f5       	brcc	.+88     	; 0x7dea <main+0xc6>
    7d92:	45 01       	movw	r8, r10
    7d94:	e8 94       	clt
    7d96:	87 f8       	bld	r8, 7
    7d98:	99 24       	eor	r9, r9
    7d9a:	a1 14       	cp	r10, r1
    7d9c:	b1 04       	cpc	r11, r1
    7d9e:	99 f0       	breq	.+38     	; 0x7dc6 <main+0xa2>
    7da0:	81 14       	cp	r8, r1
    7da2:	91 04       	cpc	r9, r1
    7da4:	81 f4       	brne	.+32     	; 0x7dc6 <main+0xa2>
    7da6:	ae 01       	movw	r20, r28
    7da8:	4f 57       	subi	r20, 0x7F	; 127
    7daa:	5f 4f       	sbci	r21, 0xFF	; 255
    7dac:	b7 01       	movw	r22, r14
    7dae:	c8 01       	movw	r24, r16
    7db0:	96 95       	lsr	r25
    7db2:	98 2f       	mov	r25, r24
    7db4:	88 27       	eor	r24, r24
    7db6:	97 95       	ror	r25
    7db8:	87 95       	ror	r24
    7dba:	5f dd       	rcall	.-1346   	; 0x787a <_ZL12writeToFlashjPhRj>
    7dbc:	85 b1       	in	r24, 0x05	; 5
    7dbe:	87 25       	eor	r24, r7
    7dc0:	85 b9       	out	0x05, r24	; 5
    7dc2:	0f 5f       	subi	r16, 0xFF	; 255
    7dc4:	1f 4f       	sbci	r17, 0xFF	; 255
    7dc6:	c5 01       	movw	r24, r10
    7dc8:	82 96       	adiw	r24, 0x22	; 34
    7dca:	bc dd       	rcall	.-1160   	; 0x7944 <_ZL17getWordFromSourcehj.constprop.6>
    7dcc:	f7 01       	movw	r30, r14
    7dce:	e8 0d       	add	r30, r8
    7dd0:	f9 1d       	adc	r31, r9
    7dd2:	90 83       	st	Z, r25
    7dd4:	f5 01       	movw	r30, r10
    7dd6:	31 96       	adiw	r30, 0x01	; 1
    7dd8:	ef 77       	andi	r30, 0x7F	; 127
    7dda:	ff 27       	eor	r31, r31
    7ddc:	ee 0d       	add	r30, r14
    7dde:	ff 1d       	adc	r31, r15
    7de0:	80 83       	st	Z, r24
    7de2:	92 e0       	ldi	r25, 0x02	; 2
    7de4:	a9 0e       	add	r10, r25
    7de6:	b1 1c       	adc	r11, r1
    7de8:	d1 cf       	rjmp	.-94     	; 0x7d8c <main+0x68>
    7dea:	0f 5f       	subi	r16, 0xFF	; 255
    7dec:	1f 4f       	sbci	r17, 0xFF	; 255
    7dee:	16 95       	lsr	r17
    7df0:	10 2f       	mov	r17, r16
    7df2:	00 27       	eor	r16, r16
    7df4:	17 95       	ror	r17
    7df6:	07 95       	ror	r16
    7df8:	c8 01       	movw	r24, r16
    7dfa:	b6 01       	movw	r22, r12
    7dfc:	2c d0       	rcall	.+88     	; 0x7e56 <__udivmodhi4>
    7dfe:	f7 01       	movw	r30, r14
    7e00:	e8 1b       	sub	r30, r24
    7e02:	f9 0b       	sbc	r31, r25
    7e04:	e0 58       	subi	r30, 0x80	; 128
    7e06:	ff 4f       	sbci	r31, 0xFF	; 255
    7e08:	8f ef       	ldi	r24, 0xFF	; 255
    7e0a:	9f 01       	movw	r18, r30
    7e0c:	2e 19       	sub	r18, r14
    7e0e:	3f 09       	sbc	r19, r15
    7e10:	20 38       	cpi	r18, 0x80	; 128
    7e12:	31 05       	cpc	r19, r1
    7e14:	10 f4       	brcc	.+4      	; 0x7e1a <main+0xf6>
    7e16:	81 93       	st	Z+, r24
    7e18:	f8 cf       	rjmp	.-16     	; 0x7e0a <main+0xe6>
    7e1a:	ae 01       	movw	r20, r28
    7e1c:	4f 57       	subi	r20, 0x7F	; 127
    7e1e:	5f 4f       	sbci	r21, 0xFF	; 255
    7e20:	b7 01       	movw	r22, r14
    7e22:	c8 01       	movw	r24, r16
    7e24:	80 58       	subi	r24, 0x80	; 128
    7e26:	91 09       	sbc	r25, r1
    7e28:	28 dd       	rcall	.-1456   	; 0x787a <_ZL12writeToFlashjPhRj>
    7e2a:	28 9a       	sbi	0x05, 0	; 5
    7e2c:	cf 57       	subi	r28, 0x7F	; 127
    7e2e:	df 4f       	sbci	r29, 0xFF	; 255
    7e30:	e8 81       	ld	r30, Y
    7e32:	f9 81       	ldd	r31, Y+1	; 0x01
    7e34:	c1 58       	subi	r28, 0x81	; 129
    7e36:	d0 40       	sbci	r29, 0x00	; 0
    7e38:	09 95       	icall
    7e3a:	ff cf       	rjmp	.-2      	; 0x7e3a <main+0x116>
    7e3c:	84 e2       	ldi	r24, 0x24	; 36
    7e3e:	90 e0       	ldi	r25, 0x00	; 0
    7e40:	81 dd       	rcall	.-1278   	; 0x7944 <_ZL17getWordFromSourcehj.constprop.6>
    7e42:	98 27       	eor	r25, r24
    7e44:	89 27       	eor	r24, r25
    7e46:	98 27       	eor	r25, r24
    7e48:	cf 57       	subi	r28, 0x7F	; 127
    7e4a:	df 4f       	sbci	r29, 0xFF	; 255
    7e4c:	99 83       	std	Y+1, r25	; 0x01
    7e4e:	88 83       	st	Y, r24
    7e50:	c1 58       	subi	r28, 0x81	; 129
    7e52:	d0 40       	sbci	r29, 0x00	; 0
    7e54:	eb cf       	rjmp	.-42     	; 0x7e2c <main+0x108>

00007e56 <__udivmodhi4>:
    7e56:	aa 1b       	sub	r26, r26
    7e58:	bb 1b       	sub	r27, r27
    7e5a:	51 e1       	ldi	r21, 0x11	; 17
    7e5c:	07 c0       	rjmp	.+14     	; 0x7e6c <__udivmodhi4_ep>

00007e5e <__udivmodhi4_loop>:
    7e5e:	aa 1f       	adc	r26, r26
    7e60:	bb 1f       	adc	r27, r27
    7e62:	a6 17       	cp	r26, r22
    7e64:	b7 07       	cpc	r27, r23
    7e66:	10 f0       	brcs	.+4      	; 0x7e6c <__udivmodhi4_ep>
    7e68:	a6 1b       	sub	r26, r22
    7e6a:	b7 0b       	sbc	r27, r23

00007e6c <__udivmodhi4_ep>:
    7e6c:	88 1f       	adc	r24, r24
    7e6e:	99 1f       	adc	r25, r25
    7e70:	5a 95       	dec	r21
    7e72:	a9 f7       	brne	.-22     	; 0x7e5e <__udivmodhi4_loop>
    7e74:	80 95       	com	r24
    7e76:	90 95       	com	r25
    7e78:	bc 01       	movw	r22, r24
    7e7a:	cd 01       	movw	r24, r26
    7e7c:	08 95       	ret

00007e7e <_exit>:
    7e7e:	f8 94       	cli

00007e80 <__stop_program>:
    7e80:	ff cf       	rjmp	.-2      	; 0x7e80 <__stop_program>
