   1               		.file	"miniboot.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
 118               	_ZL12writeToFlashjPhRj:
 119               		.stabd	46,0,0
   1:miniboot.c    **** //
   2:miniboot.c    **** //  Fuses :     Ext: 0xFF, Hi: 0xD8, Lo: 0xE2
   3:miniboot.c    **** //
   4:miniboot.c    **** 
   5:miniboot.c    **** #include "Drivers/CRC/crc32.h"
   6:miniboot.c    **** #include "bootloader.h"
   7:miniboot.c    **** #include "eeprom.h"
   8:miniboot.c    **** #include "flash.h"
   9:miniboot.c    **** #include "i2c_communication.h"
  10:miniboot.c    **** #include "init.h"
  11:miniboot.c    **** 
  12:miniboot.c    **** static inline uint16_t getDataStartAddressInSource(const uint8_t i2c_address) {
  13:miniboot.c    ****   return application_byte_offset;
  14:miniboot.c    **** }
  15:miniboot.c    **** 
  16:miniboot.c    **** static inline uint16_t getDataLength(const uint8_t i2c_address) {
  17:miniboot.c    ****   return getWordFromSource(i2c_address, application_length_byte_offset);
  18:miniboot.c    **** }
  19:miniboot.c    **** 
  20:miniboot.c    **** static inline void writeToFlash(const uint16_t address, uint8_t *data,
  21:miniboot.c    ****                                 uint16_t &application_start) {
 121               	.LM0:
 122               	.LFBB1:
 123 0000 CF93      		push r28
 124 0002 DF93      		push r29
 125               	/* prologue: function */
 126               	/* frame size = 0 */
 127               	/* stack size = 2 */
 128               	.L__stack_usage = 2
 129 0004 DB01      		movw r26,r22
 130 0006 FA01      		movw r30,r20
  22:miniboot.c    **** 
  23:miniboot.c    ****   if (0 == address && 0 == application_start) {
 132               	.LM1:
 133 0008 0097      		sbiw r24,0
 134 000a 01F4      		brne .L2
 136               	.LM2:
 137 000c 2081      		ld r18,Z
 138 000e 3181      		ldd r19,Z+1
 139 0010 232B      		or r18,r19
 140 0012 01F4      		brne .L2
  24:miniboot.c    ****     application_start = static_cast<uint16_t>(data[RESET_VECTOR_ARGUMENT_ADDRESS]) << 8;
 142               	.LM3:
 143 0014 1296      		adiw r26,2
 144 0016 2C91      		ld r18,X
 145 0018 1297      		sbiw r26,2
 146 001a 30E0      		ldi r19,0
 147 001c 322F      		mov r19,r18
 148 001e 2227      		clr r18
 149 0020 3183      		std Z+1,r19
 150 0022 2083      		st Z,r18
  25:miniboot.c    ****     application_start |=
  26:miniboot.c    ****         static_cast<uint8_t>(data[RESET_VECTOR_ARGUMENT_ADDRESS + 1]);
 152               	.LM4:
 153 0024 1396      		adiw r26,3
 154 0026 4C91      		ld r20,X
 155 0028 1397      		sbiw r26,3
 156 002a 242B      		or r18,r20
 157 002c 3183      		std Z+1,r19
 158 002e 2083      		st Z,r18
  27:miniboot.c    **** 
  28:miniboot.c    ****     data[RESET_VECTOR] = static_cast<uint8_t>(jmp_instruction);
 160               	.LM5:
 161 0030 2CE0      		ldi r18,lo8(12)
 162 0032 2C93      		st X,r18
  29:miniboot.c    ****     data[RESET_VECTOR + 1] = static_cast<uint8_t>(jmp_instruction >> 8);
 164               	.LM6:
 165 0034 24E9      		ldi r18,lo8(-108)
 166 0036 1196      		adiw r26,1
 167 0038 2C93      		st X,r18
 168 003a 1197      		sbiw r26,1
  30:miniboot.c    **** 
  31:miniboot.c    ****     data[RESET_VECTOR_ARGUMENT_ADDRESS] = static_cast<uint8_t>(
  32:miniboot.c    ****         static_cast<uint16_t>(BOOTLOADER_START_ADDRESS) / 2);
 170               	.LM7:
 171 003c 1296      		adiw r26,2
 172 003e 1C92      		st X,__zero_reg__
 173 0040 1297      		sbiw r26,2
  33:miniboot.c    ****     data[RESET_VECTOR_ARGUMENT_ADDRESS + 1] = static_cast<uint8_t>(
  34:miniboot.c    ****         (static_cast<uint16_t>(BOOTLOADER_START_ADDRESS) / 2) >> 8);
 175               	.LM8:
 176 0042 2CE3      		ldi r18,lo8(60)
 177 0044 1396      		adiw r26,3
 178 0046 2C93      		st X,r18
 179 0048 1397      		sbiw r26,3
 180               	.L2:
 181               	.LBB25:
 182               	.LBB26:
 183               	.LBB27:
 185               	.Ltext1:
   1:flash.h       **** #pragma once
   2:flash.h       **** 
   3:flash.h       **** #include <avr/boot.h>
   4:flash.h       **** #include <avr/wdt.h>
   5:flash.h       **** 
   6:flash.h       **** #include "bootloader.h"
   7:flash.h       **** 
   8:flash.h       **** static inline void eraseApplication() {
   9:flash.h       ****   uint16_t ptr = BOOTLOADER_START_ADDRESS;
  10:flash.h       ****   do {
  11:flash.h       ****     ptr -= SPM_PAGESIZE;
  12:flash.h       ****     boot_page_erase(ptr);
  13:flash.h       ****     boot_spm_busy_wait();
  14:flash.h       ****   } while (ptr);
  15:flash.h       ****   wdt_reset();
  16:flash.h       **** }
  17:flash.h       **** 
  18:flash.h       **** static inline void erasePage(const uint16_t address) {
  19:flash.h       ****   boot_page_erase(address);
 187               	.LM9:
 188 004a 23E0      		ldi r18,lo8(3)
 189 004c FC01      		movw r30,r24
 190               	/* #APP */
 191               	 ;  19 "flash.h" 1
 192 004e 2093 5700 		sts 87, r18
 193 0052 E895      		spm
 194               		
 195               	 ;  0 "" 2
 196               	/* #NOAPP */
 197               	.L3:
  20:flash.h       ****   boot_spm_busy_wait();
 199               	.LM10:
 200 0054 07B6      		in __tmp_reg__,0x37
 201 0056 00FC      		sbrc __tmp_reg__,0
 202 0058 00C0      		rjmp .L3
 203 005a 40E0      		ldi r20,0
 204               	.LBE27:
 205               	.LBE26:
 206               	.LBB28:
 207               	.LBB29:
  21:flash.h       **** }
  22:flash.h       **** 
  23:flash.h       **** static inline void writeToPageBuffer(const uint16_t address, uint8_t *data) {
  24:flash.h       ****   erasePage(address);
  25:flash.h       ****   for (uint8_t i = 0; i < SPM_PAGESIZE; i += 2) {
  26:flash.h       ****     uint16_t w = *data++;
  27:flash.h       ****     w += (*data++) << 8;
  28:flash.h       ****     boot_page_fill(address + i, w);
 209               	.LM11:
 210 005c 51E0      		ldi r21,lo8(1)
 211 005e EC01      		movw r28,r24
 212 0060 CA1B      		sub r28,r26
 213 0062 DB0B      		sbc r29,r27
 214               	.L4:
  26:flash.h       ****     w += (*data++) << 8;
 216               	.LM12:
 217 0064 6C91      		ld r22,X
 219               	.LM13:
 220 0066 FE01      		movw r30,r28
 221 0068 EA0F      		add r30,r26
 222 006a FB1F      		adc r31,r27
 223 006c 1196      		adiw r26,1
 224 006e 2C91      		ld r18,X
 225 0070 1197      		sbiw r26,1
 226 0072 30E0      		ldi r19,0
 227 0074 322F      		mov r19,r18
 228 0076 2227      		clr r18
 229 0078 260F      		add r18,r22
 230 007a 311D      		adc r19,__zero_reg__
 231               	/* #APP */
 232               	 ;  28 "flash.h" 1
 233 007c 0901      		movw  r0, r18
 234 007e 5093 5700 		sts 87, r21
 235 0082 E895      		spm
 236 0084 1124      		clr  r1
 237               		
 238               	 ;  0 "" 2
 239               	/* #NOAPP */
 240               	.LBE29:
  25:flash.h       ****     uint16_t w = *data++;
 242               	.LM14:
 243 0086 4E5F      		subi r20,lo8(-(2))
 244 0088 1296      		adiw r26,2
 245 008a 4038      		cpi r20,lo8(-128)
 246 008c 01F4      		brne .L4
 247               	.LBE28:
 248               	.LBE25:
 249               	.LBB30:
 250               	.LBB31:
  29:flash.h       ****   }
  30:flash.h       **** }
  31:flash.h       **** 
  32:flash.h       **** static inline void writePageBufferToFlash(const uint16_t address) {
  33:flash.h       ****   boot_page_write(address);
 252               	.LM15:
 253 008e 25E0      		ldi r18,lo8(5)
 254 0090 FC01      		movw r30,r24
 255               	/* #APP */
 256               	 ;  33 "flash.h" 1
 257 0092 2093 5700 		sts 87, r18
 258 0096 E895      		spm
 259               		
 260               	 ;  0 "" 2
 261               	/* #NOAPP */
 262               	.L5:
  34:flash.h       ****   boot_spm_busy_wait();
 264               	.LM16:
 265 0098 07B6      		in __tmp_reg__,0x37
 266 009a 00FC      		sbrc __tmp_reg__,0
 267 009c 00C0      		rjmp .L5
  35:flash.h       ****   boot_rww_enable();
 269               	.LM17:
 270 009e 81E1      		ldi r24,lo8(17)
 271               	/* #APP */
 272               	 ;  35 "flash.h" 1
 273 00a0 8093 5700 		sts 87, r24
 274 00a4 E895      		spm
 275               		
 276               	 ;  0 "" 2
 277               	/* epilogue start */
 278               	/* #NOAPP */
 279               	.LBE31:
 280               	.LBE30:
 282               	.Ltext2:
  35:miniboot.c    ****   }
  36:miniboot.c    **** 
  37:miniboot.c    ****   writeToPageBuffer(address, data);
  38:miniboot.c    ****   writePageBufferToFlash(address);
  39:miniboot.c    **** }
 284               	.LM18:
 285 00a6 DF91      		pop r29
 286 00a8 CF91      		pop r28
 287 00aa 0895      		ret
 292               	.Lscope1:
 294               		.stabd	78,0,0
 297               	_ZL8readBytehj.constprop.6:
 298               		.stabd	46,0,0
 300               	.Ltext3:
   1:i2c_communication.h **** #pragma once
   2:i2c_communication.h **** 
   3:i2c_communication.h **** #include "I2C-master-lib/i2c_master.h"
   4:i2c_communication.h **** 
   5:i2c_communication.h **** static inline uint8_t readByte(const uint8_t source_address,
 302               	.LM19:
 303               	.LFBB2:
 304 00ac CF93      		push r28
 305 00ae DF93      		push r29
 306               	/* prologue: function */
 307               	/* frame size = 0 */
 308               	/* stack size = 2 */
 309               	.L__stack_usage = 2
 310 00b0 EC01      		movw r28,r24
   6:i2c_communication.h ****                                const uint16_t register_address) {
   7:i2c_communication.h ****   uint8_t data = 0xFF;
   8:i2c_communication.h ****   uint8_t write_source_address = source_address << 1;
   9:i2c_communication.h ****   i2c_start(write_source_address);
 312               	.LM20:
 313 00b2 80EA      		ldi r24,lo8(-96)
 314 00b4 0E94 0000 		call _Z9i2c_starth
  10:i2c_communication.h ****   i2c_write(register_address >> 8);
 316               	.LM21:
 317 00b8 8D2F      		mov r24,r29
 318 00ba 0E94 0000 		call _Z9i2c_writeh
  11:i2c_communication.h ****   i2c_write(register_address);
 320               	.LM22:
 321 00be 8C2F      		mov r24,r28
 322 00c0 0E94 0000 		call _Z9i2c_writeh
  12:i2c_communication.h ****   i2c_stop();
 324               	.LM23:
 325 00c4 0E94 0000 		call _Z8i2c_stopv
  13:i2c_communication.h **** 
  14:i2c_communication.h ****   uint8_t read_source_address = write_source_address | 0x01;
  15:i2c_communication.h ****   i2c_start(read_source_address);
 327               	.LM24:
 328 00c8 81EA      		ldi r24,lo8(-95)
 329 00ca 0E94 0000 		call _Z9i2c_starth
 330               	/* epilogue start */
  16:i2c_communication.h ****   data = i2c_read_ack();
  17:i2c_communication.h **** 
  18:i2c_communication.h ****   return data;
  19:i2c_communication.h **** }
 332               	.LM25:
 333 00ce DF91      		pop r29
 334 00d0 CF91      		pop r28
  16:i2c_communication.h ****   data = i2c_read_ack();
 336               	.LM26:
 337 00d2 0C94 0000 		jmp _Z12i2c_read_ackv
 339               	.Lscope2:
 341               		.stabd	78,0,0
 345               	_ZL17getWordFromSourcehj.constprop.5:
 346               		.stabd	46,0,0
  20:i2c_communication.h **** 
  21:i2c_communication.h **** static inline uint16_t getWordFromSource(const uint8_t i2c_address,
 348               	.LM27:
 349               	.LFBB3:
 350 00d6 0F93      		push r16
 351 00d8 1F93      		push r17
 352 00da CF93      		push r28
 353 00dc DF93      		push r29
 354               	/* prologue: function */
 355               	/* frame size = 0 */
 356               	/* stack size = 4 */
 357               	.L__stack_usage = 4
 358 00de 8C01      		movw r16,r24
  22:i2c_communication.h ****                                          const uint16_t data_address) {
  23:i2c_communication.h ****   uint16_t result = static_cast<uint16_t>(readByte(i2c_address, data_address))
 360               	.LM28:
 361 00e0 0E94 0000 		call _ZL8readBytehj.constprop.6
  24:i2c_communication.h ****                     << 8;
 363               	.LM29:
 364 00e4 C82F      		mov r28,r24
 365 00e6 D0E0      		ldi r29,0
 366 00e8 DC2F      		mov r29,r28
 367 00ea CC27      		clr r28
  25:i2c_communication.h ****   result |= static_cast<uint16_t>(readByte(i2c_address, data_address + 1));
 369               	.LM30:
 370 00ec C801      		movw r24,r16
 371 00ee 0196      		adiw r24,1
 372 00f0 0E94 0000 		call _ZL8readBytehj.constprop.6
  26:i2c_communication.h ****   return result;
  27:i2c_communication.h **** }
 374               	.LM31:
 375 00f4 9E01      		movw r18,r28
 376 00f6 282B      		or r18,r24
 377 00f8 C901      		movw r24,r18
 378               	/* epilogue start */
 379 00fa DF91      		pop r29
 380 00fc CF91      		pop r28
 381 00fe 1F91      		pop r17
 382 0100 0F91      		pop r16
 383 0102 0895      		ret
 385               	.Lscope3:
 387               		.stabd	78,0,0
 390               	_ZL7isCrcOkh.constprop.3:
 391               		.stabd	46,0,0
 393               	.Ltext4:
  40:miniboot.c    **** 
  41:miniboot.c    **** static inline bool isCrcOk(const uint8_t i2c_address) {
 395               	.LM32:
 396               	.LFBB4:
 397 0104 3F92      		push r3
 398 0106 4F92      		push r4
 399 0108 5F92      		push r5
 400 010a 6F92      		push r6
 401 010c 7F92      		push r7
 402 010e 8F92      		push r8
 403 0110 9F92      		push r9
 404 0112 AF92      		push r10
 405 0114 BF92      		push r11
 406 0116 CF92      		push r12
 407 0118 DF92      		push r13
 408 011a EF92      		push r14
 409 011c FF92      		push r15
 410 011e 0F93      		push r16
 411 0120 1F93      		push r17
 412 0122 CF93      		push r28
 413 0124 DF93      		push r29
 414 0126 CDB7      		in r28,__SP_L__
 415 0128 DEB7      		in r29,__SP_H__
 416 012a D450      		subi r29,4
 417 012c 0FB6      		in __tmp_reg__,__SREG__
 418 012e F894      		cli
 419 0130 DEBF      		out __SP_H__,r29
 420 0132 0FBE      		out __SREG__,__tmp_reg__
 421 0134 CDBF      		out __SP_L__,r28
 422               	/* prologue: function */
 423               	/* frame size = 1024 */
 424               	/* stack size = 1041 */
 425               	.L__stack_usage = 1041
 426               	.LBB45:
 427               	.LBB46:
  17:miniboot.c    **** }
 429               	.LM33:
 430 0136 80E2      		ldi r24,lo8(32)
 431 0138 90E0      		ldi r25,0
 432 013a 0E94 0000 		call _ZL17getWordFromSourcehj.constprop.5
 433 013e 7C01      		movw r14,r24
 434 0140 FE01      		movw r30,r28
 435 0142 3196      		adiw r30,1
 436 0144 40E0      		ldi r20,0
 437 0146 50E0      		ldi r21,0
 438 0148 BA01      		movw r22,r20
 439 014a 6F01      		movw r12,r30
 440               	.L15:
 441 014c DB01      		movw r26,r22
 442 014e CA01      		movw r24,r20
 443 0150 28E0      		ldi r18,lo8(8)
 444               	.L14:
 445               	.LBE46:
 446               	.LBE45:
 447               	.LBB47:
 448               	.LBB48:
 449               	.LBB49:
 450               	.LBB50:
 451               	.LBB51:
 453               	.Ltext5:
   1:Drivers/CRC/crc32.h **** #pragma once
   2:Drivers/CRC/crc32.h **** 
   3:Drivers/CRC/crc32.h **** #include <stdint.h>
   4:Drivers/CRC/crc32.h **** 
   5:Drivers/CRC/crc32.h **** static constexpr uint32_t polynomial_representation = 0xEDB88320UL;
   6:Drivers/CRC/crc32.h **** static constexpr uint16_t crc_table_size = 0x100;
   7:Drivers/CRC/crc32.h **** 
   8:Drivers/CRC/crc32.h **** static inline uint32_t crc32_for_byte(uint32_t r) {
   9:Drivers/CRC/crc32.h ****   for (uint8_t i = 0; i < 8; ++i) {
  10:Drivers/CRC/crc32.h ****     r = (r & 1 ? 0 : polynomial_representation) ^ r >> 1;
 455               	.LM34:
 456 0152 80FD      		sbrc r24,0
 457 0154 00C0      		rjmp .L22
 458 0156 00E2      		ldi r16,lo8(32)
 459 0158 802E      		mov r8,r16
 460 015a 03E8      		ldi r16,lo8(-125)
 461 015c 902E      		mov r9,r16
 462 015e 08EB      		ldi r16,lo8(-72)
 463 0160 A02E      		mov r10,r16
 464 0162 0DEE      		ldi r16,lo8(-19)
 465 0164 B02E      		mov r11,r16
 466 0166 00C0      		rjmp .L13
 467               	.L22:
 468 0168 812C      		mov r8,__zero_reg__
 469 016a 912C      		mov r9,__zero_reg__
 470 016c 5401      		movw r10,r8
 471               	.L13:
 472 016e B695      		lsr r27
 473 0170 A795      		ror r26
 474 0172 9795      		ror r25
 475 0174 8795      		ror r24
 476 0176 8825      		eor r24,r8
 477 0178 9925      		eor r25,r9
 478 017a AA25      		eor r26,r10
 479 017c BB25      		eor r27,r11
 480 017e 2150      		subi r18,lo8(-(-1))
   9:Drivers/CRC/crc32.h ****     r = (r & 1 ? 0 : polynomial_representation) ^ r >> 1;
 482               	.LM35:
 483 0180 01F4      		brne .L14
 484               	.LBE51:
 485               	.LBE50:
 486               	.LBE49:
  11:Drivers/CRC/crc32.h ****   }
  12:Drivers/CRC/crc32.h ****   return r ^ (uint32_t)0xFF000000L;
  13:Drivers/CRC/crc32.h **** }
  14:Drivers/CRC/crc32.h **** 
  15:Drivers/CRC/crc32.h **** static inline void init_table(uint32_t *crc_table) {
  16:Drivers/CRC/crc32.h ****   for (uint16_t i = 0; i < crc_table_size; ++i) {
  17:Drivers/CRC/crc32.h ****     crc_table[i] = crc32_for_byte(i);
 488               	.LM36:
 489 0182 B095      		com r27
 490 0184 8193      		st Z+,r24
 491 0186 9193      		st Z+,r25
 492 0188 A193      		st Z+,r26
 493 018a B193      		st Z+,r27
 494 018c 4F5F      		subi r20,-1
 495 018e 5F4F      		sbci r21,-1
 496 0190 6F4F      		sbci r22,-1
 497 0192 7F4F      		sbci r23,-1
  16:Drivers/CRC/crc32.h ****     crc_table[i] = crc32_for_byte(i);
 499               	.LM37:
 500 0194 4115      		cp r20,__zero_reg__
 501 0196 21E0      		ldi r18,1
 502 0198 5207      		cpc r21,r18
 503 019a 6105      		cpc r22,__zero_reg__
 504 019c 7105      		cpc r23,__zero_reg__
 505 019e 01F4      		brne .L15
 506 01a0 412C      		mov r4,__zero_reg__
 507 01a2 512C      		mov r5,__zero_reg__
 508 01a4 3201      		movw r6,r4
 509 01a6 00E0      		ldi r16,0
 510 01a8 10E0      		ldi r17,0
 511               	.LBE48:
 512               	.LBE47:
 513               	.LBB52:
 515               	.Ltext6:
  42:miniboot.c    ****   bool status = false;
  43:miniboot.c    ****   uint32_t crc = 0;
  44:miniboot.c    ****   uint16_t start_address = getDataStartAddressInSource(i2c_address);
  45:miniboot.c    ****   uint16_t length = getDataLength(i2c_address);
  46:miniboot.c    **** 
  47:miniboot.c    ****   uint32_t table[crc_table_size];
  48:miniboot.c    ****   init_table(&table[0]);
  49:miniboot.c    **** 
  50:miniboot.c    ****   for (uint16_t pos = 0; pos < length + 1;
 517               	.LM38:
 518 01aa 4701      		movw r8,r14
 519 01ac 8FEF      		ldi r24,-1
 520 01ae 881A      		sub r8,r24
 521 01b0 980A      		sbc r9,r24
 522               	.LBB53:
  51:miniboot.c    ****        pos += 2) { // length +1 in case of odd number lengths
  52:miniboot.c    ****     if (pos >= length)
  53:miniboot.c    ****       break;
  54:miniboot.c    **** 
  55:miniboot.c    ****     uint16_t data = getWordFromSource(i2c_address, pos + start_address);
  56:miniboot.c    ****     if (pos == length - 1)
 524               	.LM39:
 525 01b2 5701      		movw r10,r14
 526 01b4 91E0      		ldi r25,1
 527 01b6 A91A      		sub r10,r25
 528 01b8 B108      		sbc r11,__zero_reg__
  57:miniboot.c    ****       data &= 0xFF00;
  58:miniboot.c    **** 
  59:miniboot.c    ****     uint8_t to_little_endian[2];
  60:miniboot.c    ****     to_little_endian[0] = static_cast<uint8_t>(data >> 8);
  61:miniboot.c    ****     to_little_endian[1] = static_cast<uint8_t>(data);
  62:miniboot.c    **** 
  63:miniboot.c    ****     crc32(reinterpret_cast<const void *>(&to_little_endian[0]), 2, &table[0],
  64:miniboot.c    ****           &crc);
  65:miniboot.c    **** 
  66:miniboot.c    ****     uint8_t toggle_led_every_x_bytes = 128;
  67:miniboot.c    ****     if (0 == pos % toggle_led_every_x_bytes)
  68:miniboot.c    ****       LED_TOGGLE();
 530               	.LM40:
 531 01ba 40E2      		ldi r20,lo8(32)
 532 01bc 342E      		mov r3,r20
 533               	.L20:
 534               	.LBE53:
  50:miniboot.c    ****        pos += 2) { // length +1 in case of odd number lengths
 536               	.LM41:
 537 01be 0815      		cp r16,r8
 538 01c0 1905      		cpc r17,r9
 539 01c2 00F4      		brsh .L16
 540               	.LBB56:
  52:miniboot.c    ****       break;
 542               	.LM42:
 543 01c4 0E15      		cp r16,r14
 544 01c6 1F05      		cpc r17,r15
 545 01c8 00F4      		brsh .L16
  55:miniboot.c    ****     if (pos == length - 1)
 547               	.LM43:
 548 01ca C801      		movw r24,r16
 549 01cc 8296      		adiw r24,34
 550 01ce 0E94 0000 		call _ZL17getWordFromSourcehj.constprop.5
  56:miniboot.c    ****       data &= 0xFF00;
 552               	.LM44:
 553 01d2 0A15      		cp r16,r10
 554 01d4 1B05      		cpc r17,r11
 555 01d6 01F4      		brne .L18
  57:miniboot.c    **** 
 557               	.LM45:
 558 01d8 8827      		clr r24
 559               	.L18:
 560               	.LBB54:
 561               	.LBB55:
 563               	.Ltext7:
  18:Drivers/CRC/crc32.h ****   }
  19:Drivers/CRC/crc32.h **** }
  20:Drivers/CRC/crc32.h **** 
  21:Drivers/CRC/crc32.h **** static inline void crc32(const void *data, const uint16_t length,
  22:Drivers/CRC/crc32.h ****                          const uint32_t *crc_table, uint32_t *crc) {
  23:Drivers/CRC/crc32.h ****   for (uint16_t i = 0; i < length; ++i) {
  24:Drivers/CRC/crc32.h ****     *crc = crc_table[static_cast<uint8_t>(*crc) ^ ((uint8_t *)data)[i]] ^
 565               	.LM46:
 566 01da 9425      		eor r25,r4
  25:Drivers/CRC/crc32.h ****            *crc >> 8;
 568               	.LM47:
 569 01dc 452C      		mov r4,r5
 570 01de 562C      		mov r5,r6
 571 01e0 672C      		mov r6,r7
 572 01e2 7724      		clr r7
  24:Drivers/CRC/crc32.h ****            *crc >> 8;
 574               	.LM48:
 575 01e4 F601      		movw r30,r12
 576 01e6 24E0      		ldi r18,lo8(4)
 577 01e8 929F      		mul r25,r18
 578 01ea E00D      		add r30,r0
 579 01ec F11D      		adc r31,r1
 580 01ee 1124      		clr __zero_reg__
 581 01f0 4081      		ld r20,Z
 582 01f2 5181      		ldd r21,Z+1
 583 01f4 6281      		ldd r22,Z+2
 584 01f6 7381      		ldd r23,Z+3
 585 01f8 4426      		eor r4,r20
 586 01fa 5526      		eor r5,r21
 587 01fc 6626      		eor r6,r22
 588 01fe 7726      		eor r7,r23
 589 0200 8425      		eor r24,r4
 591               	.LM49:
 592 0202 452C      		mov r4,r5
 593 0204 562C      		mov r5,r6
 594 0206 672C      		mov r6,r7
 595 0208 7724      		clr r7
  24:Drivers/CRC/crc32.h ****            *crc >> 8;
 597               	.LM50:
 598 020a F601      		movw r30,r12
 599 020c 94E0      		ldi r25,lo8(4)
 600 020e 899F      		mul r24,r25
 601 0210 E00D      		add r30,r0
 602 0212 F11D      		adc r31,r1
 603 0214 1124      		clr __zero_reg__
 604 0216 8081      		ld r24,Z
 605 0218 9181      		ldd r25,Z+1
 606 021a A281      		ldd r26,Z+2
 607 021c B381      		ldd r27,Z+3
 608 021e 4826      		eor r4,r24
 609 0220 5926      		eor r5,r25
 610 0222 6A26      		eor r6,r26
 611 0224 7B26      		eor r7,r27
 612               	.LBE55:
 613               	.LBE54:
 615               	.Ltext8:
  67:miniboot.c    ****       LED_TOGGLE();
 617               	.LM51:
 618 0226 C801      		movw r24,r16
 619 0228 8F77      		andi r24,127
 620 022a 9927      		clr r25
 621 022c 892B      		or r24,r25
 622 022e 01F4      		brne .L19
 624               	.LM52:
 625 0230 85B1      		in r24,0x5
 626 0232 8325      		eor r24,r3
 627 0234 85B9      		out 0x5,r24
 628               	.L19:
 629               	.LBE56:
  50:miniboot.c    ****        pos += 2) { // length +1 in case of odd number lengths
 631               	.LM53:
 632 0236 0E5F      		subi r16,-2
 633 0238 1F4F      		sbci r17,-1
 634 023a 00C0      		rjmp .L20
 635               	.L16:
 636               	.LBE52:
  69:miniboot.c    ****   }
  70:miniboot.c    **** 
  71:miniboot.c    ****   uint32_t expected_crc = static_cast<uint32_t>(getWordFromSource(
 638               	.LM54:
 639 023c 8CE1      		ldi r24,lo8(28)
 640 023e 90E0      		ldi r25,0
 641 0240 0E94 0000 		call _ZL17getWordFromSourcehj.constprop.5
  72:miniboot.c    ****                               i2c_address, application_crc_expected_index))
  73:miniboot.c    ****                           << 16;
 643               	.LM55:
 644 0244 6C01      		movw r12,r24
 645 0246 E12C      		mov r14,__zero_reg__
 646 0248 F12C      		mov r15,__zero_reg__
 647 024a 7601      		movw r14,r12
 648 024c DD24      		clr r13
 649 024e CC24      		clr r12
  74:miniboot.c    ****   expected_crc |= static_cast<uint32_t>(
  75:miniboot.c    ****       getWordFromSource(i2c_address, application_crc_expected_index + 2));
 651               	.LM56:
 652 0250 8EE1      		ldi r24,lo8(30)
 653 0252 90E0      		ldi r25,0
 654 0254 0E94 0000 		call _ZL17getWordFromSourcehj.constprop.5
  76:miniboot.c    **** 
  77:miniboot.c    ****   if (crc == expected_crc) {
  78:miniboot.c    ****     status = true;
  79:miniboot.c    ****   }
  80:miniboot.c    ****   return status;
 656               	.LM57:
 657 0258 A0E0      		ldi r26,0
 658 025a B0E0      		ldi r27,0
 659 025c C82A      		or r12,r24
 660 025e D92A      		or r13,r25
 661 0260 EA2A      		or r14,r26
 662 0262 FB2A      		or r15,r27
 663 0264 81E0      		ldi r24,lo8(1)
 664 0266 C414      		cp r12,r4
 665 0268 D504      		cpc r13,r5
 666 026a E604      		cpc r14,r6
 667 026c F704      		cpc r15,r7
 668 026e 01F0      		breq .L21
 669 0270 80E0      		ldi r24,0
 670               	.L21:
 671               	/* epilogue start */
  81:miniboot.c    **** }
 673               	.LM58:
 674 0272 DC5F      		subi r29,-4
 675 0274 0FB6      		in __tmp_reg__,__SREG__
 676 0276 F894      		cli
 677 0278 DEBF      		out __SP_H__,r29
 678 027a 0FBE      		out __SREG__,__tmp_reg__
 679 027c CDBF      		out __SP_L__,r28
 680 027e DF91      		pop r29
 681 0280 CF91      		pop r28
 682 0282 1F91      		pop r17
 683 0284 0F91      		pop r16
 684 0286 FF90      		pop r15
 685 0288 EF90      		pop r14
 686 028a DF90      		pop r13
 687 028c CF90      		pop r12
 688 028e BF90      		pop r11
 689 0290 AF90      		pop r10
 690 0292 9F90      		pop r9
 691 0294 8F90      		pop r8
 692 0296 7F90      		pop r7
 693 0298 6F90      		pop r6
 694 029a 5F90      		pop r5
 695 029c 4F90      		pop r4
 696 029e 3F90      		pop r3
 697 02a0 0895      		ret
 711               	.Lscope4:
 713               		.stabd	78,0,0
 714               		.section	.text.startup,"ax",@progbits
 716               	.global	main
 718               	main:
 719               		.stabd	46,0,0
  82:miniboot.c    **** 
  83:miniboot.c    **** static inline void writeFlashFromI2C(const uint8_t i2c_address,
  84:miniboot.c    ****                                      uint16_t &application_start) {
  85:miniboot.c    ****   uint16_t start_address = getDataStartAddressInSource(i2c_address);
  86:miniboot.c    ****   uint16_t length = getDataLength(i2c_address);
  87:miniboot.c    ****   uint8_t buf[SPM_PAGESIZE];
  88:miniboot.c    ****   uint16_t writes = 0;
  89:miniboot.c    **** 
  90:miniboot.c    ****   for (uint16_t pos = 0; pos < length; pos += 2) {
  91:miniboot.c    ****     if (pos > 0 && (0 == (pos % SPM_PAGESIZE))) {
  92:miniboot.c    ****       writeToFlash(writes * SPM_PAGESIZE, &buf[0], application_start);
  93:miniboot.c    ****       LED_TOGGLE();
  94:miniboot.c    ****       ++writes;
  95:miniboot.c    ****     }
  96:miniboot.c    ****     uint16_t data = getWordFromSource(i2c_address, pos + start_address);
  97:miniboot.c    ****     buf[pos % SPM_PAGESIZE] = static_cast<uint8_t>(data >> 8);
  98:miniboot.c    ****     buf[(pos + 1) % SPM_PAGESIZE] = static_cast<uint8_t>(data);
  99:miniboot.c    ****   }
 100:miniboot.c    **** 
 101:miniboot.c    ****   for (uint16_t pos = SPM_PAGESIZE -
 102:miniboot.c    ****                       (static_cast<uint16_t>(writes + 1) *
 103:miniboot.c    ****                        static_cast<uint16_t>(SPM_PAGESIZE)) %
 104:miniboot.c    ****                           length;
 105:miniboot.c    ****        pos < SPM_PAGESIZE; ++pos) {
 106:miniboot.c    ****     buf[pos] = 0xFF; // reset contents, since these bytes were not filled in
 107:miniboot.c    ****                      // this page and have value from previous page
 108:miniboot.c    ****   }
 109:miniboot.c    **** 
 110:miniboot.c    ****   writeToFlash(writes * SPM_PAGESIZE, &buf[0], application_start);
 111:miniboot.c    ****   LED_OFF();
 112:miniboot.c    **** }
 113:miniboot.c    **** 
 114:miniboot.c    **** [[ noreturn ]]
 115:miniboot.c    **** static inline void leaveBootloader(uint16_t &application_start) {
 116:miniboot.c    ****   // hold my beer and watch this!
 117:miniboot.c    ****   reinterpret_cast<void (*)(void)>(application_start)();
 118:miniboot.c    ****   while (1)
 119:miniboot.c    ****     ;
 120:miniboot.c    **** }
 121:miniboot.c    **** 
 122:miniboot.c    **** static inline bool isReflashNecessary(uint32_t &i2c_application_timestamp) {
 123:miniboot.c    ****   uint32_t current_application_timestamp =
 124:miniboot.c    ****       readLatestApplicationTimestampFromInternalEeprom();
 125:miniboot.c    **** 
 126:miniboot.c    ****   i2c_application_timestamp =
 127:miniboot.c    ****       static_cast<uint32_t>(getWordFromSource(
 128:miniboot.c    ****           source_i2c_address_for_program, timestamp_application_byte_offset))
 129:miniboot.c    ****       << 16;
 130:miniboot.c    ****   i2c_application_timestamp |= static_cast<uint32_t>(getWordFromSource(
 131:miniboot.c    ****       source_i2c_address_for_program, timestamp_application_byte_offset + 2));
 132:miniboot.c    **** 
 133:miniboot.c    ****   if (eeprom_not_programmed == current_application_timestamp)
 134:miniboot.c    ****     return true;
 135:miniboot.c    ****   if (i2c_application_timestamp != current_application_timestamp)
 136:miniboot.c    ****     return true;
 137:miniboot.c    ****   return false;
 138:miniboot.c    **** }
 139:miniboot.c    **** 
 140:miniboot.c    **** int main() {
 721               	.LM59:
 722               	.LFBB5:
 723 0000 CF93      		push r28
 724 0002 DF93      		push r29
 725 0004 CDB7      		in r28,__SP_L__
 726 0006 DEB7      		in r29,__SP_H__
 727 0008 C258      		subi r28,-126
 728 000a D109      		sbc r29,__zero_reg__
 729 000c 0FB6      		in __tmp_reg__,__SREG__
 730 000e F894      		cli
 731 0010 DEBF      		out __SP_H__,r29
 732 0012 0FBE      		out __SREG__,__tmp_reg__
 733 0014 CDBF      		out __SP_L__,r28
 734               	/* prologue: function */
 735               	/* frame size = 130 */
 736               	/* stack size = 132 */
 737               	.L__stack_usage = 132
 738               	.LBB82:
 739               	.LBB83:
 740               	.LBB84:
 741               	.LBB85:
 743               	.Ltext9:
   1:init.h        **** #pragma once
   2:init.h        **** 
   3:init.h        **** #include "I2C-master-lib/i2c_master.h"
   4:init.h        **** #include "io.h"
   5:init.h        **** #include <avr/wdt.h>
   6:init.h        **** 
   7:init.h        **** static inline void initIO() { LED_INIT(); }
   8:init.h        **** 
   9:init.h        **** static inline void disableWatchdog() {
  10:init.h        ****   wdt_reset();
 745               	.LM60:
 746               	/* #APP */
 747               	 ;  10 "init.h" 1
 748 0016 A895      		wdr
 749               	 ;  0 "" 2
  11:init.h        ****   MCUSR = 0;
 751               	.LM61:
 752               	/* #NOAPP */
 753 0018 14BE      		out 0x34,__zero_reg__
  12:init.h        ****   WDTCSR |= (1 << WDCE) | (1 << WDE);
 755               	.LM62:
 756 001a 8091 6000 		lds r24,96
 757 001e 8861      		ori r24,lo8(24)
 758 0020 8093 6000 		sts 96,r24
  13:init.h        ****   WDTCSR = 0;
 760               	.LM63:
 761 0024 1092 6000 		sts 96,__zero_reg__
  14:init.h        ****   asm("cli");
 763               	.LM64:
 764               	/* #APP */
 765               	 ;  14 "init.h" 1
 766 0028 F894      		cli
 767               	 ;  0 "" 2
 768               	/* #NOAPP */
 769               	.LBE85:
 770               	.LBE84:
  15:init.h        **** }
  16:init.h        **** 
  17:init.h        **** static inline void init() {
  18:init.h        ****   disableWatchdog();
  19:init.h        ****   i2c_init();
 772               	.LM65:
 773 002a 0E94 0000 		call _Z8i2c_initv
 774               	.LBB86:
 775               	.LBB87:
   7:init.h        **** 
 777               	.LM66:
 778 002e 2D9A      		sbi 0x5,5
 779 0030 80E2      		ldi r24,lo8(32)
 780 0032 84B9      		out 0x4,r24
 781               	.LBE87:
 782               	.LBE86:
 783               	.LBE83:
 784               	.LBE82:
 786               	.Ltext10:
 141:miniboot.c    **** 
 142:miniboot.c    ****   init();
 143:miniboot.c    **** 
 144:miniboot.c    ****   uint32_t i2c_application_timestamp;
 145:miniboot.c    ****   uint16_t application_start = 0;
 788               	.LM67:
 789 0034 CF57      		subi r28,lo8(-129)
 790 0036 DF4F      		sbci r29,hi8(-129)
 791 0038 1982      		std Y+1,__zero_reg__
 792 003a 1882      		st Y,__zero_reg__
 793 003c C158      		subi r28,lo8(129)
 794 003e D040      		sbci r29,hi8(129)
 795               	.LBB88:
 796               	.LBB89:
 797               	.LBB90:
 798               	.LBB91:
 799               	.LBB92:
 801               	.Ltext11:
   1:eeprom.h      **** #pragma once
   2:eeprom.h      **** 
   3:eeprom.h      **** #include "bootloader.h"
   4:eeprom.h      **** #include <avr/boot.h>
   5:eeprom.h      **** #include <avr/eeprom.h>
   6:eeprom.h      **** 
   7:eeprom.h      **** #if 0
   8:eeprom.h      **** void writeToInternalEeprom(const uint16_t data){
   9:eeprom.h      ****   eeprom_write_byte (reinterpret_cast<uint8_t
  10:eeprom.h      **** *>(EEPROM_CONFIGURATION_START_BYTE+4),data>>8);
  11:eeprom.h      ****   eeprom_write_byte (reinterpret_cast<uint8_t
  12:eeprom.h      **** *>(EEPROM_CONFIGURATION_START_BYTE+5),data);
  13:eeprom.h      ****   boot_spm_busy_wait();
  14:eeprom.h      **** }
  15:eeprom.h      **** 
  16:eeprom.h      **** void writeToInternalEeprom(const uint32_t data) {
  17:eeprom.h      ****   eeprom_write_byte(
  18:eeprom.h      ****       reinterpret_cast<uint8_t *>(EEPROM_CONFIGURATION_START_BYTE + 4),
  19:eeprom.h      ****       data >> 24);
  20:eeprom.h      ****   eeprom_write_byte(
  21:eeprom.h      ****       reinterpret_cast<uint8_t *>(EEPROM_CONFIGURATION_START_BYTE + 5),
  22:eeprom.h      ****       data >> 16);
  23:eeprom.h      ****   eeprom_write_byte(
  24:eeprom.h      ****       reinterpret_cast<uint8_t *>(EEPROM_CONFIGURATION_START_BYTE + 6),
  25:eeprom.h      ****       data >> 8);
  26:eeprom.h      ****   eeprom_write_byte(
  27:eeprom.h      ****       reinterpret_cast<uint8_t *>(EEPROM_CONFIGURATION_START_BYTE + 7), data);
  28:eeprom.h      ****   boot_spm_busy_wait();
  29:eeprom.h      **** }
  30:eeprom.h      **** #endif // #if 0
  31:eeprom.h      **** 
  32:eeprom.h      **** static inline void writeLatestApplicationTimestampToInternalEeprom(
  33:eeprom.h      ****     const uint32_t latest_timestamp) {
  34:eeprom.h      ****   eeprom_write_byte(
  35:eeprom.h      ****       reinterpret_cast<uint8_t *>(EEPROM_CONFIGURATION_START_BYTE),
  36:eeprom.h      ****       latest_timestamp >> 24);
  37:eeprom.h      ****   eeprom_write_byte(
  38:eeprom.h      ****       reinterpret_cast<uint8_t *>(EEPROM_CONFIGURATION_START_BYTE + 1),
  39:eeprom.h      ****       latest_timestamp >> 16);
  40:eeprom.h      ****   eeprom_write_byte(
  41:eeprom.h      ****       reinterpret_cast<uint8_t *>(EEPROM_CONFIGURATION_START_BYTE + 2),
  42:eeprom.h      ****       latest_timestamp >> 8);
  43:eeprom.h      ****   eeprom_write_byte(
  44:eeprom.h      ****       reinterpret_cast<uint8_t *>(EEPROM_CONFIGURATION_START_BYTE + 3),
  45:eeprom.h      ****       latest_timestamp);
  46:eeprom.h      ****   boot_spm_busy_wait();
  47:eeprom.h      **** }
  48:eeprom.h      **** 
  49:eeprom.h      **** static inline uint32_t readLatestApplicationTimestampFromInternalEeprom() {
  50:eeprom.h      ****   uint32_t result =
  51:eeprom.h      ****       static_cast<uint32_t>(eeprom_read_byte(
 803               	.LM68:
 804 0040 86EF      		ldi r24,lo8(-10)
 805 0042 93E0      		ldi r25,lo8(3)
 806 0044 0E94 0000 		call eeprom_read_byte
  52:eeprom.h      ****           reinterpret_cast<uint8_t *>(EEPROM_CONFIGURATION_START_BYTE)))
  53:eeprom.h      ****       << 24;
 808               	.LM69:
 809 0048 C82E      		mov r12,r24
 810 004a D12C      		mov r13,__zero_reg__
 811 004c E12C      		mov r14,__zero_reg__
 812 004e F12C      		mov r15,__zero_reg__
 813 0050 FC2C      		mov r15,r12
 814 0052 EE24      		clr r14
 815 0054 DD24      		clr r13
 816 0056 CC24      		clr r12
  54:eeprom.h      ****   result |= static_cast<uint32_t>(eeprom_read_byte(reinterpret_cast<uint8_t *>(
 818               	.LM70:
 819 0058 87EF      		ldi r24,lo8(-9)
 820 005a 93E0      		ldi r25,lo8(3)
 821 005c 0E94 0000 		call eeprom_read_byte
  55:eeprom.h      ****                 EEPROM_CONFIGURATION_START_BYTE + 1)))
  56:eeprom.h      ****             << 16;
 823               	.LM71:
 824 0060 E82A      		or r14,r24
  57:eeprom.h      ****   result |= static_cast<uint32_t>(eeprom_read_byte(reinterpret_cast<uint8_t *>(
 826               	.LM72:
 827 0062 88EF      		ldi r24,lo8(-8)
 828 0064 93E0      		ldi r25,lo8(3)
 829 0066 0E94 0000 		call eeprom_read_byte
 830 006a 182F      		mov r17,r24
  58:eeprom.h      ****                 EEPROM_CONFIGURATION_START_BYTE + 2)))
  59:eeprom.h      ****             << 8;
  60:eeprom.h      ****   result |= static_cast<uint32_t>(eeprom_read_byte(
 832               	.LM73:
 833 006c 89EF      		ldi r24,lo8(-7)
 834 006e 93E0      		ldi r25,lo8(3)
 835 0070 0E94 0000 		call eeprom_read_byte
  61:eeprom.h      ****       reinterpret_cast<uint8_t *>(EEPROM_CONFIGURATION_START_BYTE + 3)));
 837               	.LM74:
 838 0074 C82A      		or r12,r24
 839 0076 D12A      		or r13,r17
 840               	.L26:
  62:eeprom.h      ****   boot_spm_busy_wait();
 842               	.LM75:
 843 0078 07B6      		in __tmp_reg__,0x37
 844 007a 00FC      		sbrc __tmp_reg__,0
 845 007c 00C0      		rjmp .L26
 846               	.LBE92:
 847               	.LBE91:
 849               	.Ltext12:
 127:miniboot.c    ****           source_i2c_address_for_program, timestamp_application_byte_offset))
 851               	.LM76:
 852 007e 84E1      		ldi r24,lo8(20)
 853 0080 90E0      		ldi r25,0
 854 0082 0E94 0000 		call _ZL17getWordFromSourcehj.constprop.5
 129:miniboot.c    ****   i2c_application_timestamp |= static_cast<uint32_t>(getWordFromSource(
 856               	.LM77:
 857 0086 2C01      		movw r4,r24
 858 0088 612C      		mov r6,__zero_reg__
 859 008a 712C      		mov r7,__zero_reg__
 860 008c 5201      		movw r10,r4
 861 008e 9924      		clr r9
 862 0090 8824      		clr r8
 130:miniboot.c    ****       source_i2c_address_for_program, timestamp_application_byte_offset + 2));
 864               	.LM78:
 865 0092 86E1      		ldi r24,lo8(22)
 866 0094 90E0      		ldi r25,0
 867 0096 0E94 0000 		call _ZL17getWordFromSourcehj.constprop.5
 131:miniboot.c    **** 
 869               	.LM79:
 870 009a 2C01      		movw r4,r24
 871 009c 612C      		mov r6,__zero_reg__
 872 009e 712C      		mov r7,__zero_reg__
 873 00a0 4828      		or r4,r8
 874 00a2 5928      		or r5,r9
 875 00a4 6A28      		or r6,r10
 876 00a6 7B28      		or r7,r11
 133:miniboot.c    ****     return true;
 878               	.LM80:
 879 00a8 8FEF      		ldi r24,-1
 880 00aa C816      		cp r12,r24
 881 00ac D806      		cpc r13,r24
 882 00ae E806      		cpc r14,r24
 883 00b0 F806      		cpc r15,r24
 884 00b2 01F0      		breq .L27
 135:miniboot.c    ****     return true;
 886               	.LM81:
 887 00b4 4C14      		cp r4,r12
 888 00b6 5D04      		cpc r5,r13
 889 00b8 6E04      		cpc r6,r14
 890 00ba 7F04      		cpc r7,r15
 891 00bc 01F4      		brne .L27
 892               	.L28:
 893               	.LBE90:
 894               	.LBE89:
 895               	.LBB93:
 146:miniboot.c    **** 
 147:miniboot.c    ****   if (isReflashNecessary(i2c_application_timestamp) &&
 148:miniboot.c    ****       isCrcOk(source_i2c_address_for_program)) {
 149:miniboot.c    ****     eraseApplication();
 150:miniboot.c    ****     writeFlashFromI2C(source_i2c_address_for_program, application_start);
 151:miniboot.c    ****     writeLatestApplicationTimestampToInternalEeprom(i2c_application_timestamp);
 152:miniboot.c    ****   } else {
 153:miniboot.c    ****     uint16_t address_in_external_eeprom = getWordFromSource(
 154:miniboot.c    ****         source_i2c_address_for_program, application_start_address_byte_offset);
 897               	.LM82:
 898 00be 84E2      		ldi r24,lo8(36)
 899 00c0 90E0      		ldi r25,0
 900 00c2 0E94 0000 		call _ZL17getWordFromSourcehj.constprop.5
 155:miniboot.c    **** 
 156:miniboot.c    ****     application_start = address_in_external_eeprom >> 8;
 157:miniboot.c    ****     application_start |= static_cast<uint16_t>(static_cast<uint8_t>(address_in_external_eeprom))<<8
 902               	.LM83:
 903 00c6 9827      		eor r25,r24
 904 00c8 8927      		eor r24,r25
 905 00ca 9827      		eor r25,r24
 906 00cc CF57      		subi r28,lo8(-129)
 907 00ce DF4F      		sbci r29,hi8(-129)
 908 00d0 9983      		std Y+1,r25
 909 00d2 8883      		st Y,r24
 910 00d4 C158      		subi r28,lo8(129)
 911 00d6 D040      		sbci r29,hi8(129)
 912               	.L37:
 913               	.LBE93:
 914               	.LBE88:
 915               	.LBB107:
 916               	.LBB108:
 117:miniboot.c    ****   while (1)
 918               	.LM84:
 919 00d8 CF57      		subi r28,lo8(-129)
 920 00da DF4F      		sbci r29,hi8(-129)
 921 00dc E881      		ld r30,Y
 922 00de F981      		ldd r31,Y+1
 923 00e0 C158      		subi r28,lo8(129)
 924 00e2 D040      		sbci r29,hi8(129)
 925 00e4 0995      		icall
 926               	.L38:
 927 00e6 00C0      		rjmp .L38
 928               	.L27:
 929               	.LBE108:
 930               	.LBE107:
 931               	.LBB109:
 148:miniboot.c    ****     eraseApplication();
 933               	.LM85:
 934 00e8 0E94 0000 		call _ZL7isCrcOkh.constprop.3
 147:miniboot.c    ****       isCrcOk(source_i2c_address_for_program)) {
 936               	.LM86:
 937 00ec 8823      		tst r24
 938 00ee 01F0      		breq .L28
 939 00f0 E0E0      		ldi r30,0
 940 00f2 F8E7      		ldi r31,lo8(120)
 941               	.LBB94:
 942               	.LBB95:
 944               	.Ltext13:
  12:flash.h       ****     boot_spm_busy_wait();
 946               	.LM87:
 947 00f4 83E0      		ldi r24,lo8(3)
 948               	.L30:
  11:flash.h       ****     boot_page_erase(ptr);
 950               	.LM88:
 951 00f6 E058      		subi r30,-128
 952 00f8 F109      		sbc r31,__zero_reg__
  12:flash.h       ****     boot_spm_busy_wait();
 954               	.LM89:
 955               	/* #APP */
 956               	 ;  12 "flash.h" 1
 957 00fa 8093 5700 		sts 87, r24
 958 00fe E895      		spm
 959               		
 960               	 ;  0 "" 2
 961               	/* #NOAPP */
 962               	.L29:
  13:flash.h       ****   } while (ptr);
 964               	.LM90:
 965 0100 07B6      		in __tmp_reg__,0x37
 966 0102 00FC      		sbrc __tmp_reg__,0
 967 0104 00C0      		rjmp .L29
  10:flash.h       ****     ptr -= SPM_PAGESIZE;
 969               	.LM91:
 970 0106 3097      		sbiw r30,0
 971 0108 01F4      		brne .L30
  15:flash.h       **** }
 973               	.LM92:
 974               	/* #APP */
 975               	 ;  15 "flash.h" 1
 976 010a A895      		wdr
 977               	 ;  0 "" 2
 978               	/* #NOAPP */
 979               	.LBE95:
 980               	.LBE94:
 981               	.LBB96:
 982               	.LBB97:
 983               	.LBB98:
 984               	.LBB99:
 986               	.Ltext14:
  17:miniboot.c    **** }
 988               	.LM93:
 989 010c 80E2      		ldi r24,lo8(32)
 990 010e 90E0      		ldi r25,0
 991 0110 0E94 0000 		call _ZL17getWordFromSourcehj.constprop.5
 992 0114 4C01      		movw r8,r24
 993               	.LBE99:
 994               	.LBE98:
 995               	.LBB100:
  90:miniboot.c    ****     if (pos > 0 && (0 == (pos % SPM_PAGESIZE))) {
 997               	.LM94:
 998 0116 E12C      		mov r14,__zero_reg__
 999 0118 F12C      		mov r15,__zero_reg__
 1000               	.LBE100:
  88:miniboot.c    **** 
 1002               	.LM95:
 1003 011a 00E0      		ldi r16,0
 1004 011c 10E0      		ldi r17,0
 1005 011e CE01      		movw r24,r28
 1006 0120 0196      		adiw r24,1
 1007 0122 6C01      		movw r12,r24
 1008               	.LBB103:
 1009               	.LBB101:
  93:miniboot.c    ****       ++writes;
 1011               	.LM96:
 1012 0124 F0E2      		ldi r31,lo8(32)
 1013 0126 3F2E      		mov r3,r31
 1014               	.L33:
 1015               	.LBE101:
  90:miniboot.c    ****     if (pos > 0 && (0 == (pos % SPM_PAGESIZE))) {
 1017               	.LM97:
 1018 0128 E814      		cp r14,r8
 1019 012a F904      		cpc r15,r9
 1020 012c 00F4      		brsh .L31
 1021 012e 5701      		movw r10,r14
 1022 0130 E894      		clt
 1023 0132 A7F8      		bld r10,7
 1024 0134 BB24      		clr r11
 1025               	.LBB102:
  91:miniboot.c    ****       writeToFlash(writes * SPM_PAGESIZE, &buf[0], application_start);
 1027               	.LM98:
 1028 0136 E114      		cp r14,__zero_reg__
 1029 0138 F104      		cpc r15,__zero_reg__
 1030 013a 01F0      		breq .L32
 1031 013c A114      		cp r10,__zero_reg__
 1032 013e B104      		cpc r11,__zero_reg__
 1033 0140 01F4      		brne .L32
  92:miniboot.c    ****       LED_TOGGLE();
 1035               	.LM99:
 1036 0142 AE01      		movw r20,r28
 1037 0144 4F57      		subi r20,127
 1038 0146 5F4F      		sbci r21,-1
 1039 0148 B601      		movw r22,r12
 1040 014a C801      		movw r24,r16
 1041 014c 9695      		lsr r25
 1042 014e 982F      		mov r25,r24
 1043 0150 8827      		clr r24
 1044 0152 9795      		ror r25
 1045 0154 8795      		ror r24
 1046 0156 0E94 0000 		call _ZL12writeToFlashjPhRj
  93:miniboot.c    ****       ++writes;
 1048               	.LM100:
 1049 015a 85B1      		in r24,0x5
 1050 015c 8325      		eor r24,r3
 1051 015e 85B9      		out 0x5,r24
  94:miniboot.c    ****     }
 1053               	.LM101:
 1054 0160 0F5F      		subi r16,-1
 1055 0162 1F4F      		sbci r17,-1
 1056               	.L32:
  96:miniboot.c    ****     buf[pos % SPM_PAGESIZE] = static_cast<uint8_t>(data >> 8);
 1058               	.LM102:
 1059 0164 C701      		movw r24,r14
 1060 0166 8296      		adiw r24,34
 1061 0168 0E94 0000 		call _ZL17getWordFromSourcehj.constprop.5
  97:miniboot.c    ****     buf[(pos + 1) % SPM_PAGESIZE] = static_cast<uint8_t>(data);
 1063               	.LM103:
 1064 016c F601      		movw r30,r12
 1065 016e EA0D      		add r30,r10
 1066 0170 FB1D      		adc r31,r11
 1067 0172 9083      		st Z,r25
  98:miniboot.c    ****   }
 1069               	.LM104:
 1070 0174 F701      		movw r30,r14
 1071 0176 3196      		adiw r30,1
 1072 0178 EF77      		andi r30,127
 1073 017a FF27      		clr r31
 1074 017c EC0D      		add r30,r12
 1075 017e FD1D      		adc r31,r13
 1076 0180 8083      		st Z,r24
 1077               	.LBE102:
  90:miniboot.c    ****     if (pos > 0 && (0 == (pos % SPM_PAGESIZE))) {
 1079               	.LM105:
 1080 0182 92E0      		ldi r25,2
 1081 0184 E90E      		add r14,r25
 1082 0186 F11C      		adc r15,__zero_reg__
 1083 0188 00C0      		rjmp .L33
 1084               	.L31:
 1085               	.LBE103:
 1086               	.LBB104:
 102:miniboot.c    ****                        static_cast<uint16_t>(SPM_PAGESIZE)) %
 1088               	.LM106:
 1089 018a 0F5F      		subi r16,-1
 1090 018c 1F4F      		sbci r17,-1
 1091 018e 1695      		lsr r17
 1092 0190 102F      		mov r17,r16
 1093 0192 0027      		clr r16
 1094 0194 1795      		ror r17
 1095 0196 0795      		ror r16
 1096 0198 C801      		movw r24,r16
 1097 019a B401      		movw r22,r8
 1098 019c 0E94 0000 		call __udivmodhi4
 1099 01a0 F601      		movw r30,r12
 1100 01a2 E81B      		sub r30,r24
 1101 01a4 F90B      		sbc r31,r25
 1102 01a6 E058      		subi r30,-128
 1103 01a8 FF4F      		sbci r31,-1
 106:miniboot.c    ****                      // this page and have value from previous page
 1105               	.LM107:
 1106 01aa 8FEF      		ldi r24,lo8(-1)
 1107               	.L35:
 105:miniboot.c    ****     buf[pos] = 0xFF; // reset contents, since these bytes were not filled in
 1109               	.LM108:
 1110 01ac 9F01      		movw r18,r30
 1111 01ae 2C19      		sub r18,r12
 1112 01b0 3D09      		sbc r19,r13
 1113 01b2 2038      		cpi r18,-128
 1114 01b4 3105      		cpc r19,__zero_reg__
 1115 01b6 00F4      		brsh .L34
 106:miniboot.c    ****                      // this page and have value from previous page
 1117               	.LM109:
 1118 01b8 8193      		st Z+,r24
 1119 01ba 00C0      		rjmp .L35
 1120               	.L34:
 1121               	.LBE104:
 110:miniboot.c    ****   LED_OFF();
 1123               	.LM110:
 1124 01bc AE01      		movw r20,r28
 1125 01be 4F57      		subi r20,127
 1126 01c0 5F4F      		sbci r21,-1
 1127 01c2 B601      		movw r22,r12
 1128 01c4 C801      		movw r24,r16
 1129 01c6 8058      		subi r24,-128
 1130 01c8 9109      		sbc r25,__zero_reg__
 1131 01ca 0E94 0000 		call _ZL12writeToFlashjPhRj
 111:miniboot.c    **** }
 1133               	.LM111:
 1134 01ce 2D9A      		sbi 0x5,5
 1135               	.LBE97:
 1136               	.LBE96:
 1137               	.LBB105:
 1138               	.LBB106:
 1140               	.Ltext15:
  36:eeprom.h      ****   eeprom_write_byte(
 1142               	.LM112:
 1143 01d0 672D      		mov r22,r7
 1144 01d2 7727      		clr r23
 1145 01d4 8827      		clr r24
 1146 01d6 9927      		clr r25
 1147 01d8 86EF      		ldi r24,lo8(-10)
 1148 01da 93E0      		ldi r25,lo8(3)
 1149 01dc 0E94 0000 		call eeprom_write_byte
  39:eeprom.h      ****   eeprom_write_byte(
 1151               	.LM113:
 1152 01e0 B301      		movw r22,r6
 1153 01e2 8827      		clr r24
 1154 01e4 9927      		clr r25
 1155 01e6 87EF      		ldi r24,lo8(-9)
 1156 01e8 93E0      		ldi r25,lo8(3)
 1157 01ea 0E94 0000 		call eeprom_write_byte
  42:eeprom.h      ****   eeprom_write_byte(
 1159               	.LM114:
 1160 01ee 9927      		clr r25
 1161 01f0 872D      		mov r24,r7
 1162 01f2 762D      		mov r23,r6
 1163 01f4 652D      		mov r22,r5
 1164 01f6 88EF      		ldi r24,lo8(-8)
 1165 01f8 93E0      		ldi r25,lo8(3)
 1166 01fa 0E94 0000 		call eeprom_write_byte
  45:eeprom.h      ****   boot_spm_busy_wait();
 1168               	.LM115:
 1169 01fe 642D      		mov r22,r4
 1170 0200 89EF      		ldi r24,lo8(-7)
 1171 0202 93E0      		ldi r25,lo8(3)
 1172 0204 0E94 0000 		call eeprom_write_byte
 1173               	.L36:
  46:eeprom.h      **** }
 1175               	.LM116:
 1176 0208 07B6      		in __tmp_reg__,0x37
 1177 020a 00FC      		sbrc __tmp_reg__,0
 1178 020c 00C0      		rjmp .L36
 1179 020e 00C0      		rjmp .L37
 1180               	.LBE106:
 1181               	.LBE105:
 1182               	.LBE109:
 1203               	.Lscope5:
 1205               		.stabd	78,0,0
 1217               		.text
 1219               	.Letext0:
 1220               		.ident	"GCC: (GNU) 5.4.0"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 miniboot.c
     /tmp/ccskGIiT.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccskGIiT.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccskGIiT.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccskGIiT.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccskGIiT.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccskGIiT.s:118    .text:0000000000000000 _ZL12writeToFlashjPhRj
     /tmp/ccskGIiT.s:297    .text:00000000000000ac _ZL8readBytehj.constprop.6
     /tmp/ccskGIiT.s:345    .text:00000000000000d6 _ZL17getWordFromSourcehj.constprop.5
     /tmp/ccskGIiT.s:390    .text:0000000000000104 _ZL7isCrcOkh.constprop.3
     /tmp/ccskGIiT.s:718    .text.startup:0000000000000000 main

UNDEFINED SYMBOLS
_Z9i2c_starth
_Z9i2c_writeh
_Z8i2c_stopv
_Z12i2c_read_ackv
_Z8i2c_initv
eeprom_read_byte
__udivmodhi4
eeprom_write_byte
