   1               		.file	"miniboot.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
 118               	_ZL12writeToFlashjPhRj:
 119               		.stabd	46,0,0
   1:miniboot.c    **** //
   2:miniboot.c    **** //  Fuses :     Ext: 0xFF, Hi: 0xD8, Lo: 0xE2
   3:miniboot.c    **** //
   4:miniboot.c    **** 
   5:miniboot.c    **** #include "crc32.h"
   6:miniboot.c    **** #include "bootloader.h"
   7:miniboot.c    **** #include "flash.h"
   8:miniboot.c    **** #include "i2c_communication.h"
   9:miniboot.c    **** #include "init.h"
  10:miniboot.c    **** 
  11:miniboot.c    **** static inline uint16_t getDataStartAddressInSource(const uint8_t i2c_address) {
  12:miniboot.c    ****   return application_byte_offset;
  13:miniboot.c    **** }
  14:miniboot.c    **** 
  15:miniboot.c    **** static inline uint16_t getDataLength(const uint8_t i2c_address) {
  16:miniboot.c    ****   return getWordFromSource(i2c_address, application_length_byte_offset);
  17:miniboot.c    **** }
  18:miniboot.c    **** 
  19:miniboot.c    **** static inline void writeToFlash(const uint16_t address, uint8_t *data,
  20:miniboot.c    ****                                 uint16_t &application_start) {
 121               	.LM0:
 122               	.LFBB1:
 123 0000 CF93      		push r28
 124 0002 DF93      		push r29
 125               	/* prologue: function */
 126               	/* frame size = 0 */
 127               	/* stack size = 2 */
 128               	.L__stack_usage = 2
 129 0004 DB01      		movw r26,r22
 130 0006 FA01      		movw r30,r20
  21:miniboot.c    **** 
  22:miniboot.c    ****   if (0 == address && 0 == application_start) {
 132               	.LM1:
 133 0008 0097      		sbiw r24,0
 134 000a 01F4      		brne .L2
 136               	.LM2:
 137 000c 2081      		ld r18,Z
 138 000e 3181      		ldd r19,Z+1
 139 0010 232B      		or r18,r19
 140 0012 01F4      		brne .L2
  23:miniboot.c    ****     application_start = static_cast<uint16_t>(data[RESET_VECTOR_ARGUMENT_ADDRESS]) << 8;
 142               	.LM3:
 143 0014 1296      		adiw r26,2
 144 0016 2C91      		ld r18,X
 145 0018 1297      		sbiw r26,2
 146 001a 30E0      		ldi r19,0
 147 001c 322F      		mov r19,r18
 148 001e 2227      		clr r18
 149 0020 3183      		std Z+1,r19
 150 0022 2083      		st Z,r18
  24:miniboot.c    ****     application_start |=
  25:miniboot.c    ****         static_cast<uint8_t>(data[RESET_VECTOR_ARGUMENT_ADDRESS + 1]);
 152               	.LM4:
 153 0024 1396      		adiw r26,3
 154 0026 4C91      		ld r20,X
 155 0028 1397      		sbiw r26,3
 156 002a 242B      		or r18,r20
 157 002c 3183      		std Z+1,r19
 158 002e 2083      		st Z,r18
  26:miniboot.c    **** 
  27:miniboot.c    ****     data[RESET_VECTOR] = static_cast<uint8_t>(jmp_instruction);
 160               	.LM5:
 161 0030 2CE0      		ldi r18,lo8(12)
 162 0032 2C93      		st X,r18
  28:miniboot.c    ****     data[RESET_VECTOR + 1] = static_cast<uint8_t>(jmp_instruction >> 8);
 164               	.LM6:
 165 0034 24E9      		ldi r18,lo8(-108)
 166 0036 1196      		adiw r26,1
 167 0038 2C93      		st X,r18
 168 003a 1197      		sbiw r26,1
  29:miniboot.c    **** 
  30:miniboot.c    ****     data[RESET_VECTOR_ARGUMENT_ADDRESS] = static_cast<uint8_t>(
  31:miniboot.c    ****         static_cast<uint16_t>(BOOTLOADER_START_ADDRESS) / 2);
 170               	.LM7:
 171 003c 1296      		adiw r26,2
 172 003e 1C92      		st X,__zero_reg__
 173 0040 1297      		sbiw r26,2
  32:miniboot.c    ****     data[RESET_VECTOR_ARGUMENT_ADDRESS + 1] = static_cast<uint8_t>(
  33:miniboot.c    ****         (static_cast<uint16_t>(BOOTLOADER_START_ADDRESS) / 2) >> 8);
 175               	.LM8:
 176 0042 2CE3      		ldi r18,lo8(60)
 177 0044 1396      		adiw r26,3
 178 0046 2C93      		st X,r18
 179 0048 1397      		sbiw r26,3
 180               	.L2:
 181               	.LBB29:
 182               	.LBB30:
 183               	.LBB31:
 185               	.Ltext1:
   1:flash.h       **** #pragma once
   2:flash.h       **** 
   3:flash.h       **** #include <avr/boot.h>
   4:flash.h       **** #include <avr/wdt.h>
   5:flash.h       **** 
   6:flash.h       **** #include "bootloader.h"
   7:flash.h       **** 
   8:flash.h       **** static inline void eraseApplication() {
   9:flash.h       ****   uint16_t ptr = BOOTLOADER_START_ADDRESS;
  10:flash.h       ****   do {
  11:flash.h       ****     ptr -= SPM_PAGESIZE;
  12:flash.h       ****     boot_page_erase(ptr);
  13:flash.h       ****     boot_spm_busy_wait();
  14:flash.h       ****   } while (ptr);
  15:flash.h       ****   wdt_reset();
  16:flash.h       **** }
  17:flash.h       **** 
  18:flash.h       **** static inline void erasePage(const uint16_t address) {
  19:flash.h       ****   boot_page_erase(address);
 187               	.LM9:
 188 004a 23E0      		ldi r18,lo8(3)
 189 004c FC01      		movw r30,r24
 190               	/* #APP */
 191               	 ;  19 "flash.h" 1
 192 004e 2093 5700 		sts 87, r18
 193 0052 E895      		spm
 194               		
 195               	 ;  0 "" 2
 196               	/* #NOAPP */
 197               	.L3:
  20:flash.h       ****   boot_spm_busy_wait();
 199               	.LM10:
 200 0054 07B6      		in __tmp_reg__,0x37
 201 0056 00FC      		sbrc __tmp_reg__,0
 202 0058 00C0      		rjmp .L3
 203 005a 40E0      		ldi r20,0
 204               	.LBE31:
 205               	.LBE30:
 206               	.LBB32:
 207               	.LBB33:
  21:flash.h       **** }
  22:flash.h       **** 
  23:flash.h       **** static inline void writeToPageBuffer(const uint16_t address, uint8_t *data) {
  24:flash.h       ****   erasePage(address);
  25:flash.h       ****   for (uint8_t i = 0; i < SPM_PAGESIZE; i += 2) {
  26:flash.h       ****     uint16_t w = *data++;
  27:flash.h       ****     w += (*data++) << 8;
  28:flash.h       ****     boot_page_fill(address + i, w);
 209               	.LM11:
 210 005c 51E0      		ldi r21,lo8(1)
 211 005e EC01      		movw r28,r24
 212 0060 CA1B      		sub r28,r26
 213 0062 DB0B      		sbc r29,r27
 214               	.L4:
  26:flash.h       ****     w += (*data++) << 8;
 216               	.LM12:
 217 0064 6C91      		ld r22,X
 219               	.LM13:
 220 0066 FE01      		movw r30,r28
 221 0068 EA0F      		add r30,r26
 222 006a FB1F      		adc r31,r27
 223 006c 1196      		adiw r26,1
 224 006e 2C91      		ld r18,X
 225 0070 1197      		sbiw r26,1
 226 0072 30E0      		ldi r19,0
 227 0074 322F      		mov r19,r18
 228 0076 2227      		clr r18
 229 0078 260F      		add r18,r22
 230 007a 311D      		adc r19,__zero_reg__
 231               	/* #APP */
 232               	 ;  28 "flash.h" 1
 233 007c 0901      		movw  r0, r18
 234 007e 5093 5700 		sts 87, r21
 235 0082 E895      		spm
 236 0084 1124      		clr  r1
 237               		
 238               	 ;  0 "" 2
 239               	/* #NOAPP */
 240               	.LBE33:
  25:flash.h       ****     uint16_t w = *data++;
 242               	.LM14:
 243 0086 4E5F      		subi r20,lo8(-(2))
 244 0088 1296      		adiw r26,2
 245 008a 4038      		cpi r20,lo8(-128)
 246 008c 01F4      		brne .L4
 247               	.LBE32:
 248               	.LBE29:
 249               	.LBB34:
 250               	.LBB35:
  29:flash.h       ****   }
  30:flash.h       **** }
  31:flash.h       **** 
  32:flash.h       **** static inline void writePageBufferToFlash(const uint16_t address) {
  33:flash.h       ****   boot_page_write(address);
 252               	.LM15:
 253 008e 25E0      		ldi r18,lo8(5)
 254 0090 FC01      		movw r30,r24
 255               	/* #APP */
 256               	 ;  33 "flash.h" 1
 257 0092 2093 5700 		sts 87, r18
 258 0096 E895      		spm
 259               		
 260               	 ;  0 "" 2
 261               	/* #NOAPP */
 262               	.L5:
  34:flash.h       ****   boot_spm_busy_wait();
 264               	.LM16:
 265 0098 07B6      		in __tmp_reg__,0x37
 266 009a 00FC      		sbrc __tmp_reg__,0
 267 009c 00C0      		rjmp .L5
  35:flash.h       ****   boot_rww_enable();
 269               	.LM17:
 270 009e 81E1      		ldi r24,lo8(17)
 271               	/* #APP */
 272               	 ;  35 "flash.h" 1
 273 00a0 8093 5700 		sts 87, r24
 274 00a4 E895      		spm
 275               		
 276               	 ;  0 "" 2
 277               	/* epilogue start */
 278               	/* #NOAPP */
 279               	.LBE35:
 280               	.LBE34:
 282               	.Ltext2:
  34:miniboot.c    ****   }
  35:miniboot.c    **** 
  36:miniboot.c    ****   writeToPageBuffer(address, data);
  37:miniboot.c    ****   writePageBufferToFlash(address);
  38:miniboot.c    **** }
 284               	.LM18:
 285 00a6 DF91      		pop r29
 286 00a8 CF91      		pop r28
 287 00aa 0895      		ret
 292               	.Lscope1:
 294               		.stabd	78,0,0
 297               	_ZL8readBytehj.constprop.7:
 298               		.stabd	46,0,0
 300               	.Ltext3:
   1:i2c_communication.h **** #pragma once
   2:i2c_communication.h **** 
   3:i2c_communication.h **** #include "I2C-master-lib/i2c_master.h"
   4:i2c_communication.h **** 
   5:i2c_communication.h **** static inline uint8_t readByte(const uint8_t source_address,
 302               	.LM19:
 303               	.LFBB2:
 304 00ac CF93      		push r28
 305 00ae DF93      		push r29
 306               	/* prologue: function */
 307               	/* frame size = 0 */
 308               	/* stack size = 2 */
 309               	.L__stack_usage = 2
 310 00b0 EC01      		movw r28,r24
   6:i2c_communication.h ****                                const uint16_t register_address) {
   7:i2c_communication.h ****   uint8_t data = 0xFF;
   8:i2c_communication.h ****   uint8_t write_source_address = source_address << 1;
   9:i2c_communication.h ****   i2c_start(write_source_address);
 312               	.LM20:
 313 00b2 80EA      		ldi r24,lo8(-96)
 314 00b4 0E94 0000 		call _Z9i2c_starth
  10:i2c_communication.h ****   i2c_write(register_address >> 8);
 316               	.LM21:
 317 00b8 8D2F      		mov r24,r29
 318 00ba 0E94 0000 		call _Z9i2c_writeh
  11:i2c_communication.h ****   i2c_write(register_address);
 320               	.LM22:
 321 00be 8C2F      		mov r24,r28
 322 00c0 0E94 0000 		call _Z9i2c_writeh
  12:i2c_communication.h ****   i2c_stop();
 324               	.LM23:
 325 00c4 0E94 0000 		call _Z8i2c_stopv
  13:i2c_communication.h **** 
  14:i2c_communication.h ****   uint8_t read_source_address = write_source_address | 0x01;
  15:i2c_communication.h ****   i2c_start(read_source_address);
 327               	.LM24:
 328 00c8 81EA      		ldi r24,lo8(-95)
 329 00ca 0E94 0000 		call _Z9i2c_starth
 330               	/* epilogue start */
  16:i2c_communication.h ****   data = i2c_read_ack();
  17:i2c_communication.h **** 
  18:i2c_communication.h ****   return data;
  19:i2c_communication.h **** }
 332               	.LM25:
 333 00ce DF91      		pop r29
 334 00d0 CF91      		pop r28
  16:i2c_communication.h ****   data = i2c_read_ack();
 336               	.LM26:
 337 00d2 0C94 0000 		jmp _Z12i2c_read_ackv
 339               	.Lscope2:
 341               		.stabd	78,0,0
 345               	_ZL17getWordFromSourcehj.constprop.6:
 346               		.stabd	46,0,0
  20:i2c_communication.h **** 
  21:i2c_communication.h **** static inline uint16_t getWordFromSource(const uint8_t i2c_address,
 348               	.LM27:
 349               	.LFBB3:
 350 00d6 0F93      		push r16
 351 00d8 1F93      		push r17
 352 00da CF93      		push r28
 353 00dc DF93      		push r29
 354               	/* prologue: function */
 355               	/* frame size = 0 */
 356               	/* stack size = 4 */
 357               	.L__stack_usage = 4
 358 00de 8C01      		movw r16,r24
  22:i2c_communication.h ****                                          const uint16_t data_address) {
  23:i2c_communication.h ****   uint16_t result = static_cast<uint16_t>(readByte(i2c_address, data_address))
 360               	.LM28:
 361 00e0 0E94 0000 		call _ZL8readBytehj.constprop.7
  24:i2c_communication.h ****                     << 8;
 363               	.LM29:
 364 00e4 C82F      		mov r28,r24
 365 00e6 D0E0      		ldi r29,0
 366 00e8 DC2F      		mov r29,r28
 367 00ea CC27      		clr r28
  25:i2c_communication.h ****   result |= static_cast<uint16_t>(readByte(i2c_address, data_address + 1));
 369               	.LM30:
 370 00ec C801      		movw r24,r16
 371 00ee 0196      		adiw r24,1
 372 00f0 0E94 0000 		call _ZL8readBytehj.constprop.7
  26:i2c_communication.h ****   return result;
  27:i2c_communication.h **** }
 374               	.LM31:
 375 00f4 9E01      		movw r18,r28
 376 00f6 282B      		or r18,r24
 377 00f8 C901      		movw r24,r18
 378               	/* epilogue start */
 379 00fa DF91      		pop r29
 380 00fc CF91      		pop r28
 381 00fe 1F91      		pop r17
 382 0100 0F91      		pop r16
 383 0102 0895      		ret
 385               	.Lscope3:
 387               		.stabd	78,0,0
 390               	_ZL7isCrcOkh.constprop.4:
 391               		.stabd	46,0,0
 393               	.Ltext4:
  39:miniboot.c    **** 
  40:miniboot.c    **** static inline bool isCrcOk(const uint8_t i2c_address) {
 395               	.LM32:
 396               	.LFBB4:
 397 0104 3F92      		push r3
 398 0106 4F92      		push r4
 399 0108 5F92      		push r5
 400 010a 6F92      		push r6
 401 010c 7F92      		push r7
 402 010e 8F92      		push r8
 403 0110 9F92      		push r9
 404 0112 AF92      		push r10
 405 0114 BF92      		push r11
 406 0116 CF92      		push r12
 407 0118 DF92      		push r13
 408 011a EF92      		push r14
 409 011c FF92      		push r15
 410 011e 0F93      		push r16
 411 0120 1F93      		push r17
 412 0122 CF93      		push r28
 413 0124 DF93      		push r29
 414 0126 CDB7      		in r28,__SP_L__
 415 0128 DEB7      		in r29,__SP_H__
 416 012a D450      		subi r29,4
 417 012c 0FB6      		in __tmp_reg__,__SREG__
 418 012e F894      		cli
 419 0130 DEBF      		out __SP_H__,r29
 420 0132 0FBE      		out __SREG__,__tmp_reg__
 421 0134 CDBF      		out __SP_L__,r28
 422               	/* prologue: function */
 423               	/* frame size = 1024 */
 424               	/* stack size = 1041 */
 425               	.L__stack_usage = 1041
 426               	.LBB49:
 427               	.LBB50:
  16:miniboot.c    **** }
 429               	.LM33:
 430 0136 80E2      		ldi r24,lo8(32)
 431 0138 90E0      		ldi r25,0
 432 013a 0E94 0000 		call _ZL17getWordFromSourcehj.constprop.6
 433 013e 7C01      		movw r14,r24
 434 0140 FE01      		movw r30,r28
 435 0142 3196      		adiw r30,1
 436 0144 40E0      		ldi r20,0
 437 0146 50E0      		ldi r21,0
 438 0148 BA01      		movw r22,r20
 439 014a 6F01      		movw r12,r30
 440               	.L15:
 441 014c DB01      		movw r26,r22
 442 014e CA01      		movw r24,r20
 443 0150 28E0      		ldi r18,lo8(8)
 444               	.L14:
 445               	.LBE50:
 446               	.LBE49:
 447               	.LBB51:
 448               	.LBB52:
 449               	.LBB53:
 450               	.LBB54:
 451               	.LBB55:
 453               	.Ltext5:
   1:crc32.h       **** #pragma once
   2:crc32.h       **** 
   3:crc32.h       **** #include <stdint.h>
   4:crc32.h       **** 
   5:crc32.h       **** static constexpr uint32_t polynomial_representation = 0xEDB88320UL;
   6:crc32.h       **** static constexpr uint16_t crc_table_size = 0x100;
   7:crc32.h       **** 
   8:crc32.h       **** static inline uint32_t crc32_for_byte(uint32_t r) {
   9:crc32.h       ****   for (uint8_t i = 0; i < 8; ++i) {
  10:crc32.h       ****     r = (r & 1 ? 0 : polynomial_representation) ^ r >> 1;
 455               	.LM34:
 456 0152 80FD      		sbrc r24,0
 457 0154 00C0      		rjmp .L22
 458 0156 00E2      		ldi r16,lo8(32)
 459 0158 802E      		mov r8,r16
 460 015a 03E8      		ldi r16,lo8(-125)
 461 015c 902E      		mov r9,r16
 462 015e 08EB      		ldi r16,lo8(-72)
 463 0160 A02E      		mov r10,r16
 464 0162 0DEE      		ldi r16,lo8(-19)
 465 0164 B02E      		mov r11,r16
 466 0166 00C0      		rjmp .L13
 467               	.L22:
 468 0168 812C      		mov r8,__zero_reg__
 469 016a 912C      		mov r9,__zero_reg__
 470 016c 5401      		movw r10,r8
 471               	.L13:
 472 016e B695      		lsr r27
 473 0170 A795      		ror r26
 474 0172 9795      		ror r25
 475 0174 8795      		ror r24
 476 0176 8825      		eor r24,r8
 477 0178 9925      		eor r25,r9
 478 017a AA25      		eor r26,r10
 479 017c BB25      		eor r27,r11
 480 017e 2150      		subi r18,lo8(-(-1))
   9:crc32.h       ****     r = (r & 1 ? 0 : polynomial_representation) ^ r >> 1;
 482               	.LM35:
 483 0180 01F4      		brne .L14
 484               	.LBE55:
 485               	.LBE54:
 486               	.LBE53:
  11:crc32.h       ****   }
  12:crc32.h       ****   return r ^ (uint32_t)0xFF000000L;
  13:crc32.h       **** }
  14:crc32.h       **** 
  15:crc32.h       **** static inline void init_table(uint32_t *crc_table) {
  16:crc32.h       ****   for (uint16_t i = 0; i < crc_table_size; ++i) {
  17:crc32.h       ****     crc_table[i] = crc32_for_byte(i);
 488               	.LM36:
 489 0182 B095      		com r27
 490 0184 8193      		st Z+,r24
 491 0186 9193      		st Z+,r25
 492 0188 A193      		st Z+,r26
 493 018a B193      		st Z+,r27
 494 018c 4F5F      		subi r20,-1
 495 018e 5F4F      		sbci r21,-1
 496 0190 6F4F      		sbci r22,-1
 497 0192 7F4F      		sbci r23,-1
  16:crc32.h       ****     crc_table[i] = crc32_for_byte(i);
 499               	.LM37:
 500 0194 4115      		cp r20,__zero_reg__
 501 0196 21E0      		ldi r18,1
 502 0198 5207      		cpc r21,r18
 503 019a 6105      		cpc r22,__zero_reg__
 504 019c 7105      		cpc r23,__zero_reg__
 505 019e 01F4      		brne .L15
 506 01a0 412C      		mov r4,__zero_reg__
 507 01a2 512C      		mov r5,__zero_reg__
 508 01a4 3201      		movw r6,r4
 509 01a6 00E0      		ldi r16,0
 510 01a8 10E0      		ldi r17,0
 511               	.LBE52:
 512               	.LBE51:
 513               	.LBB56:
 515               	.Ltext6:
  41:miniboot.c    ****   bool status = false;
  42:miniboot.c    ****   uint32_t crc = 0;
  43:miniboot.c    ****   uint16_t start_address = getDataStartAddressInSource(i2c_address);
  44:miniboot.c    ****   uint16_t length = getDataLength(i2c_address);
  45:miniboot.c    **** 
  46:miniboot.c    ****   uint32_t table[crc_table_size];
  47:miniboot.c    ****   init_table(&table[0]);
  48:miniboot.c    **** 
  49:miniboot.c    ****   for (uint16_t pos = 0; pos < length + 1;
 517               	.LM38:
 518 01aa 4701      		movw r8,r14
 519 01ac 8FEF      		ldi r24,-1
 520 01ae 881A      		sub r8,r24
 521 01b0 980A      		sbc r9,r24
 522               	.LBB57:
  50:miniboot.c    ****        pos += 2) { // length +1 in case of odd number lengths
  51:miniboot.c    ****     if (pos >= length)
  52:miniboot.c    ****       break;
  53:miniboot.c    **** 
  54:miniboot.c    ****     uint16_t data = getWordFromSource(i2c_address, pos + start_address);
  55:miniboot.c    ****     if (pos == length - 1)
 524               	.LM39:
 525 01b2 5701      		movw r10,r14
 526 01b4 91E0      		ldi r25,1
 527 01b6 A91A      		sub r10,r25
 528 01b8 B108      		sbc r11,__zero_reg__
  56:miniboot.c    ****       data &= 0xFF00;
  57:miniboot.c    **** 
  58:miniboot.c    ****     uint8_t to_little_endian[2];
  59:miniboot.c    ****     to_little_endian[0] = static_cast<uint8_t>(data >> 8);
  60:miniboot.c    ****     to_little_endian[1] = static_cast<uint8_t>(data);
  61:miniboot.c    **** 
  62:miniboot.c    ****     crc32(reinterpret_cast<const void *>(&to_little_endian[0]), 2, &table[0],
  63:miniboot.c    ****           &crc);
  64:miniboot.c    **** 
  65:miniboot.c    ****     uint8_t toggle_led_every_x_bytes = 128;
  66:miniboot.c    ****     if (0 == pos % toggle_led_every_x_bytes)
  67:miniboot.c    ****       LED_TOGGLE();
 530               	.LM40:
 531 01ba 3324      		clr r3
 532 01bc 3394      		inc r3
 533               	.L20:
 534               	.LBE57:
  49:miniboot.c    ****        pos += 2) { // length +1 in case of odd number lengths
 536               	.LM41:
 537 01be 0815      		cp r16,r8
 538 01c0 1905      		cpc r17,r9
 539 01c2 00F4      		brsh .L16
 540               	.LBB60:
  51:miniboot.c    ****       break;
 542               	.LM42:
 543 01c4 0E15      		cp r16,r14
 544 01c6 1F05      		cpc r17,r15
 545 01c8 00F4      		brsh .L16
  54:miniboot.c    ****     if (pos == length - 1)
 547               	.LM43:
 548 01ca C801      		movw r24,r16
 549 01cc 8296      		adiw r24,34
 550 01ce 0E94 0000 		call _ZL17getWordFromSourcehj.constprop.6
  55:miniboot.c    ****       data &= 0xFF00;
 552               	.LM44:
 553 01d2 0A15      		cp r16,r10
 554 01d4 1B05      		cpc r17,r11
 555 01d6 01F4      		brne .L18
  56:miniboot.c    **** 
 557               	.LM45:
 558 01d8 8827      		clr r24
 559               	.L18:
 560               	.LBB58:
 561               	.LBB59:
 563               	.Ltext7:
  18:crc32.h       ****   }
  19:crc32.h       **** }
  20:crc32.h       **** 
  21:crc32.h       **** static inline void crc32(const void *data, const uint16_t length,
  22:crc32.h       ****                          const uint32_t *crc_table, uint32_t *crc) {
  23:crc32.h       ****   for (uint16_t i = 0; i < length; ++i) {
  24:crc32.h       ****     *crc = crc_table[static_cast<uint8_t>(*crc) ^ ((uint8_t *)data)[i]] ^
 565               	.LM46:
 566 01da 9425      		eor r25,r4
  25:crc32.h       ****            *crc >> 8;
 568               	.LM47:
 569 01dc 452C      		mov r4,r5
 570 01de 562C      		mov r5,r6
 571 01e0 672C      		mov r6,r7
 572 01e2 7724      		clr r7
  24:crc32.h       ****            *crc >> 8;
 574               	.LM48:
 575 01e4 F601      		movw r30,r12
 576 01e6 24E0      		ldi r18,lo8(4)
 577 01e8 929F      		mul r25,r18
 578 01ea E00D      		add r30,r0
 579 01ec F11D      		adc r31,r1
 580 01ee 1124      		clr __zero_reg__
 581 01f0 4081      		ld r20,Z
 582 01f2 5181      		ldd r21,Z+1
 583 01f4 6281      		ldd r22,Z+2
 584 01f6 7381      		ldd r23,Z+3
 585 01f8 4426      		eor r4,r20
 586 01fa 5526      		eor r5,r21
 587 01fc 6626      		eor r6,r22
 588 01fe 7726      		eor r7,r23
 589 0200 8425      		eor r24,r4
 591               	.LM49:
 592 0202 452C      		mov r4,r5
 593 0204 562C      		mov r5,r6
 594 0206 672C      		mov r6,r7
 595 0208 7724      		clr r7
  24:crc32.h       ****            *crc >> 8;
 597               	.LM50:
 598 020a F601      		movw r30,r12
 599 020c 94E0      		ldi r25,lo8(4)
 600 020e 899F      		mul r24,r25
 601 0210 E00D      		add r30,r0
 602 0212 F11D      		adc r31,r1
 603 0214 1124      		clr __zero_reg__
 604 0216 8081      		ld r24,Z
 605 0218 9181      		ldd r25,Z+1
 606 021a A281      		ldd r26,Z+2
 607 021c B381      		ldd r27,Z+3
 608 021e 4826      		eor r4,r24
 609 0220 5926      		eor r5,r25
 610 0222 6A26      		eor r6,r26
 611 0224 7B26      		eor r7,r27
 612               	.LBE59:
 613               	.LBE58:
 615               	.Ltext8:
  66:miniboot.c    ****       LED_TOGGLE();
 617               	.LM51:
 618 0226 C801      		movw r24,r16
 619 0228 8F77      		andi r24,127
 620 022a 9927      		clr r25
 621 022c 892B      		or r24,r25
 622 022e 01F4      		brne .L19
 624               	.LM52:
 625 0230 85B1      		in r24,0x5
 626 0232 8325      		eor r24,r3
 627 0234 85B9      		out 0x5,r24
 628               	.L19:
 629               	.LBE60:
  49:miniboot.c    ****        pos += 2) { // length +1 in case of odd number lengths
 631               	.LM53:
 632 0236 0E5F      		subi r16,-2
 633 0238 1F4F      		sbci r17,-1
 634 023a 00C0      		rjmp .L20
 635               	.L16:
 636               	.LBE56:
  68:miniboot.c    ****   }
  69:miniboot.c    **** 
  70:miniboot.c    ****   uint32_t expected_crc = static_cast<uint32_t>(getWordFromSource(
 638               	.LM54:
 639 023c 8CE1      		ldi r24,lo8(28)
 640 023e 90E0      		ldi r25,0
 641 0240 0E94 0000 		call _ZL17getWordFromSourcehj.constprop.6
  71:miniboot.c    ****                               i2c_address, application_crc_expected_index))
  72:miniboot.c    ****                           << 16;
 643               	.LM55:
 644 0244 6C01      		movw r12,r24
 645 0246 E12C      		mov r14,__zero_reg__
 646 0248 F12C      		mov r15,__zero_reg__
 647 024a 7601      		movw r14,r12
 648 024c DD24      		clr r13
 649 024e CC24      		clr r12
  73:miniboot.c    ****   expected_crc |= static_cast<uint32_t>(
  74:miniboot.c    ****       getWordFromSource(i2c_address, application_crc_expected_index + 2));
 651               	.LM56:
 652 0250 8EE1      		ldi r24,lo8(30)
 653 0252 90E0      		ldi r25,0
 654 0254 0E94 0000 		call _ZL17getWordFromSourcehj.constprop.6
  75:miniboot.c    **** 
  76:miniboot.c    ****   if (crc == expected_crc) {
  77:miniboot.c    ****     status = true;
  78:miniboot.c    ****   }
  79:miniboot.c    ****   return status;
 656               	.LM57:
 657 0258 A0E0      		ldi r26,0
 658 025a B0E0      		ldi r27,0
 659 025c C82A      		or r12,r24
 660 025e D92A      		or r13,r25
 661 0260 EA2A      		or r14,r26
 662 0262 FB2A      		or r15,r27
 663 0264 81E0      		ldi r24,lo8(1)
 664 0266 C414      		cp r12,r4
 665 0268 D504      		cpc r13,r5
 666 026a E604      		cpc r14,r6
 667 026c F704      		cpc r15,r7
 668 026e 01F0      		breq .L21
 669 0270 80E0      		ldi r24,0
 670               	.L21:
 671               	/* epilogue start */
  80:miniboot.c    **** }
 673               	.LM58:
 674 0272 DC5F      		subi r29,-4
 675 0274 0FB6      		in __tmp_reg__,__SREG__
 676 0276 F894      		cli
 677 0278 DEBF      		out __SP_H__,r29
 678 027a 0FBE      		out __SREG__,__tmp_reg__
 679 027c CDBF      		out __SP_L__,r28
 680 027e DF91      		pop r29
 681 0280 CF91      		pop r28
 682 0282 1F91      		pop r17
 683 0284 0F91      		pop r16
 684 0286 FF90      		pop r15
 685 0288 EF90      		pop r14
 686 028a DF90      		pop r13
 687 028c CF90      		pop r12
 688 028e BF90      		pop r11
 689 0290 AF90      		pop r10
 690 0292 9F90      		pop r9
 691 0294 8F90      		pop r8
 692 0296 7F90      		pop r7
 693 0298 6F90      		pop r6
 694 029a 5F90      		pop r5
 695 029c 4F90      		pop r4
 696 029e 3F90      		pop r3
 697 02a0 0895      		ret
 711               	.Lscope4:
 713               		.stabd	78,0,0
 714               		.section	.text.startup,"ax",@progbits
 716               	.global	main
 718               	main:
 719               		.stabd	46,0,0
  81:miniboot.c    **** 
  82:miniboot.c    **** static inline void writeFlashFromI2C(const uint8_t i2c_address,
  83:miniboot.c    ****                                      uint16_t &application_start) {
  84:miniboot.c    ****   uint16_t start_address = getDataStartAddressInSource(i2c_address);
  85:miniboot.c    ****   uint16_t length = getDataLength(i2c_address);
  86:miniboot.c    ****   uint8_t buf[SPM_PAGESIZE];
  87:miniboot.c    ****   uint16_t writes = 0;
  88:miniboot.c    **** 
  89:miniboot.c    ****   for (uint16_t pos = 0; pos < length; pos += 2) {
  90:miniboot.c    ****     if (pos > 0 && (0 == (pos % SPM_PAGESIZE))) {
  91:miniboot.c    ****       writeToFlash(writes * SPM_PAGESIZE, &buf[0], application_start);
  92:miniboot.c    ****       LED_TOGGLE();
  93:miniboot.c    ****       ++writes;
  94:miniboot.c    ****     }
  95:miniboot.c    ****     uint16_t data = getWordFromSource(i2c_address, pos + start_address);
  96:miniboot.c    ****     buf[pos % SPM_PAGESIZE] = static_cast<uint8_t>(data >> 8);
  97:miniboot.c    ****     buf[(pos + 1) % SPM_PAGESIZE] = static_cast<uint8_t>(data);
  98:miniboot.c    ****   }
  99:miniboot.c    **** 
 100:miniboot.c    ****   for (uint16_t pos = SPM_PAGESIZE -
 101:miniboot.c    ****                       (static_cast<uint16_t>(writes + 1) *
 102:miniboot.c    ****                        static_cast<uint16_t>(SPM_PAGESIZE)) %
 103:miniboot.c    ****                           length;
 104:miniboot.c    ****        pos < SPM_PAGESIZE; ++pos) {
 105:miniboot.c    ****     buf[pos] = 0xFF; // reset contents, since these bytes were not filled in
 106:miniboot.c    ****                      // this page and have value from previous page
 107:miniboot.c    ****   }
 108:miniboot.c    **** 
 109:miniboot.c    ****   writeToFlash(writes * SPM_PAGESIZE, &buf[0], application_start);
 110:miniboot.c    ****   LED_OFF();
 111:miniboot.c    **** }
 112:miniboot.c    **** 
 113:miniboot.c    **** [[ noreturn ]]
 114:miniboot.c    **** static inline void leaveBootloader(uint16_t &application_start) {
 115:miniboot.c    ****   // hold my beer and watch this!
 116:miniboot.c    ****   reinterpret_cast<void (*)(void)>(application_start)();
 117:miniboot.c    ****   while (1);
 118:miniboot.c    **** }
 119:miniboot.c    **** 
 120:miniboot.c    **** static inline bool isReflashNecessary(uint32_t &i2c_application_timestamp) {
 121:miniboot.c    **** 
 122:miniboot.c    **** // TODO: Don't reflash everytime
 123:miniboot.c    **** 
 124:miniboot.c    ****   return true;
 125:miniboot.c    **** }
 126:miniboot.c    **** 
 127:miniboot.c    **** int main() {
 721               	.LM59:
 722               	.LFBB5:
 723 0000 CF93      		push r28
 724 0002 DF93      		push r29
 725 0004 CDB7      		in r28,__SP_L__
 726 0006 DEB7      		in r29,__SP_H__
 727 0008 C258      		subi r28,-126
 728 000a D109      		sbc r29,__zero_reg__
 729 000c 0FB6      		in __tmp_reg__,__SREG__
 730 000e F894      		cli
 731 0010 DEBF      		out __SP_H__,r29
 732 0012 0FBE      		out __SREG__,__tmp_reg__
 733 0014 CDBF      		out __SP_L__,r28
 734               	/* prologue: function */
 735               	/* frame size = 130 */
 736               	/* stack size = 132 */
 737               	.L__stack_usage = 132
 738               	.LBB78:
 739               	.LBB79:
 741               	.Ltext9:
   1:init.h        **** #pragma once
   2:init.h        **** 
   3:init.h        **** #include "I2C-master-lib/i2c_master.h"
   4:init.h        **** #include "io.h"
   5:init.h        **** #include <avr/wdt.h>
   6:init.h        **** 
   7:init.h        **** static inline void initIO() { LED_INIT(); }
   8:init.h        **** 
   9:init.h        **** static inline void disableWatchdog() {
  10:init.h        ****   wdt_reset();
  11:init.h        ****   MCUSR = 0;
  12:init.h        ****   WDTCSR |= (1 << WDCE) | (1 << WDE);
  13:init.h        ****   WDTCSR = 0;
  14:init.h        ****   asm("cli");
  15:init.h        **** }
  16:init.h        **** 
  17:init.h        **** static inline void init() {
  18:init.h        ****   //disableWatchdog();
  19:init.h        ****   i2c_init();
 743               	.LM60:
 744 0016 0E94 0000 		call _Z8i2c_initv
 745               	.LBB80:
 746               	.LBB81:
   7:init.h        **** 
 748               	.LM61:
 749 001a 289A      		sbi 0x5,0
 750 001c 81E0      		ldi r24,lo8(1)
 751 001e 84B9      		out 0x4,r24
 752               	.LBE81:
 753               	.LBE80:
 754               	.LBE79:
 755               	.LBE78:
 757               	.Ltext10:
 128:miniboot.c    **** 
 129:miniboot.c    ****   init();
 130:miniboot.c    **** 
 131:miniboot.c    ****   uint32_t i2c_application_timestamp;
 132:miniboot.c    ****   uint16_t application_start = 0;
 759               	.LM62:
 760 0020 CF57      		subi r28,lo8(-129)
 761 0022 DF4F      		sbci r29,hi8(-129)
 762 0024 1982      		std Y+1,__zero_reg__
 763 0026 1882      		st Y,__zero_reg__
 764 0028 C158      		subi r28,lo8(129)
 765 002a D040      		sbci r29,hi8(129)
 766               	.LBB82:
 133:miniboot.c    **** 
 134:miniboot.c    ****   if (isReflashNecessary(i2c_application_timestamp) &&
 135:miniboot.c    ****       isCrcOk(source_i2c_address_for_program)) {
 768               	.LM63:
 769 002c 0E94 0000 		call _ZL7isCrcOkh.constprop.4
 134:miniboot.c    ****       isCrcOk(source_i2c_address_for_program)) {
 771               	.LM64:
 772 0030 8823      		tst r24
 773 0032 01F4      		brne .+2
 774 0034 00C0      		rjmp .L26
 775 0036 E0E0      		ldi r30,0
 776 0038 F8E7      		ldi r31,lo8(120)
 777               	.LBB83:
 778               	.LBB84:
 780               	.Ltext11:
  12:flash.h       ****     boot_spm_busy_wait();
 782               	.LM65:
 783 003a 83E0      		ldi r24,lo8(3)
 784               	.L28:
  11:flash.h       ****     boot_page_erase(ptr);
 786               	.LM66:
 787 003c E058      		subi r30,-128
 788 003e F109      		sbc r31,__zero_reg__
  12:flash.h       ****     boot_spm_busy_wait();
 790               	.LM67:
 791               	/* #APP */
 792               	 ;  12 "flash.h" 1
 793 0040 8093 5700 		sts 87, r24
 794 0044 E895      		spm
 795               		
 796               	 ;  0 "" 2
 797               	/* #NOAPP */
 798               	.L27:
  13:flash.h       ****   } while (ptr);
 800               	.LM68:
 801 0046 07B6      		in __tmp_reg__,0x37
 802 0048 00FC      		sbrc __tmp_reg__,0
 803 004a 00C0      		rjmp .L27
  10:flash.h       ****     ptr -= SPM_PAGESIZE;
 805               	.LM69:
 806 004c 3097      		sbiw r30,0
 807 004e 01F4      		brne .L28
  15:flash.h       **** }
 809               	.LM70:
 810               	/* #APP */
 811               	 ;  15 "flash.h" 1
 812 0050 A895      		wdr
 813               	 ;  0 "" 2
 814               	/* #NOAPP */
 815               	.LBE84:
 816               	.LBE83:
 817               	.LBB85:
 818               	.LBB86:
 819               	.LBB87:
 820               	.LBB88:
 822               	.Ltext12:
  16:miniboot.c    **** }
 824               	.LM71:
 825 0052 80E2      		ldi r24,lo8(32)
 826 0054 90E0      		ldi r25,0
 827 0056 0E94 0000 		call _ZL17getWordFromSourcehj.constprop.6
 828 005a 6C01      		movw r12,r24
 829               	.LBE88:
 830               	.LBE87:
 831               	.LBB89:
  89:miniboot.c    ****     if (pos > 0 && (0 == (pos % SPM_PAGESIZE))) {
 833               	.LM72:
 834 005c A12C      		mov r10,__zero_reg__
 835 005e B12C      		mov r11,__zero_reg__
 836               	.LBE89:
  87:miniboot.c    **** 
 838               	.LM73:
 839 0060 00E0      		ldi r16,0
 840 0062 10E0      		ldi r17,0
 841 0064 CE01      		movw r24,r28
 842 0066 0196      		adiw r24,1
 843 0068 7C01      		movw r14,r24
 844               	.LBB92:
 845               	.LBB90:
  92:miniboot.c    ****       ++writes;
 847               	.LM74:
 848 006a 7724      		clr r7
 849 006c 7394      		inc r7
 850               	.L31:
 851               	.LBE90:
  89:miniboot.c    ****     if (pos > 0 && (0 == (pos % SPM_PAGESIZE))) {
 853               	.LM75:
 854 006e AC14      		cp r10,r12
 855 0070 BD04      		cpc r11,r13
 856 0072 00F4      		brsh .L29
 857 0074 4501      		movw r8,r10
 858 0076 E894      		clt
 859 0078 87F8      		bld r8,7
 860 007a 9924      		clr r9
 861               	.LBB91:
  90:miniboot.c    ****       writeToFlash(writes * SPM_PAGESIZE, &buf[0], application_start);
 863               	.LM76:
 864 007c A114      		cp r10,__zero_reg__
 865 007e B104      		cpc r11,__zero_reg__
 866 0080 01F0      		breq .L30
 867 0082 8114      		cp r8,__zero_reg__
 868 0084 9104      		cpc r9,__zero_reg__
 869 0086 01F4      		brne .L30
  91:miniboot.c    ****       LED_TOGGLE();
 871               	.LM77:
 872 0088 AE01      		movw r20,r28
 873 008a 4F57      		subi r20,127
 874 008c 5F4F      		sbci r21,-1
 875 008e B701      		movw r22,r14
 876 0090 C801      		movw r24,r16
 877 0092 9695      		lsr r25
 878 0094 982F      		mov r25,r24
 879 0096 8827      		clr r24
 880 0098 9795      		ror r25
 881 009a 8795      		ror r24
 882 009c 0E94 0000 		call _ZL12writeToFlashjPhRj
  92:miniboot.c    ****       ++writes;
 884               	.LM78:
 885 00a0 85B1      		in r24,0x5
 886 00a2 8725      		eor r24,r7
 887 00a4 85B9      		out 0x5,r24
  93:miniboot.c    ****     }
 889               	.LM79:
 890 00a6 0F5F      		subi r16,-1
 891 00a8 1F4F      		sbci r17,-1
 892               	.L30:
  95:miniboot.c    ****     buf[pos % SPM_PAGESIZE] = static_cast<uint8_t>(data >> 8);
 894               	.LM80:
 895 00aa C501      		movw r24,r10
 896 00ac 8296      		adiw r24,34
 897 00ae 0E94 0000 		call _ZL17getWordFromSourcehj.constprop.6
  96:miniboot.c    ****     buf[(pos + 1) % SPM_PAGESIZE] = static_cast<uint8_t>(data);
 899               	.LM81:
 900 00b2 F701      		movw r30,r14
 901 00b4 E80D      		add r30,r8
 902 00b6 F91D      		adc r31,r9
 903 00b8 9083      		st Z,r25
  97:miniboot.c    ****   }
 905               	.LM82:
 906 00ba F501      		movw r30,r10
 907 00bc 3196      		adiw r30,1
 908 00be EF77      		andi r30,127
 909 00c0 FF27      		clr r31
 910 00c2 EE0D      		add r30,r14
 911 00c4 FF1D      		adc r31,r15
 912 00c6 8083      		st Z,r24
 913               	.LBE91:
  89:miniboot.c    ****     if (pos > 0 && (0 == (pos % SPM_PAGESIZE))) {
 915               	.LM83:
 916 00c8 92E0      		ldi r25,2
 917 00ca A90E      		add r10,r25
 918 00cc B11C      		adc r11,__zero_reg__
 919 00ce 00C0      		rjmp .L31
 920               	.L29:
 921               	.LBE92:
 922               	.LBB93:
 101:miniboot.c    ****                        static_cast<uint16_t>(SPM_PAGESIZE)) %
 924               	.LM84:
 925 00d0 0F5F      		subi r16,-1
 926 00d2 1F4F      		sbci r17,-1
 927 00d4 1695      		lsr r17
 928 00d6 102F      		mov r17,r16
 929 00d8 0027      		clr r16
 930 00da 1795      		ror r17
 931 00dc 0795      		ror r16
 932 00de C801      		movw r24,r16
 933 00e0 B601      		movw r22,r12
 934 00e2 0E94 0000 		call __udivmodhi4
 935 00e6 F701      		movw r30,r14
 936 00e8 E81B      		sub r30,r24
 937 00ea F90B      		sbc r31,r25
 938 00ec E058      		subi r30,-128
 939 00ee FF4F      		sbci r31,-1
 105:miniboot.c    ****                      // this page and have value from previous page
 941               	.LM85:
 942 00f0 8FEF      		ldi r24,lo8(-1)
 943               	.L33:
 104:miniboot.c    ****     buf[pos] = 0xFF; // reset contents, since these bytes were not filled in
 945               	.LM86:
 946 00f2 9F01      		movw r18,r30
 947 00f4 2E19      		sub r18,r14
 948 00f6 3F09      		sbc r19,r15
 949 00f8 2038      		cpi r18,-128
 950 00fa 3105      		cpc r19,__zero_reg__
 951 00fc 00F4      		brsh .L32
 105:miniboot.c    ****                      // this page and have value from previous page
 953               	.LM87:
 954 00fe 8193      		st Z+,r24
 955 0100 00C0      		rjmp .L33
 956               	.L32:
 957               	.LBE93:
 109:miniboot.c    ****   LED_OFF();
 959               	.LM88:
 960 0102 AE01      		movw r20,r28
 961 0104 4F57      		subi r20,127
 962 0106 5F4F      		sbci r21,-1
 963 0108 B701      		movw r22,r14
 964 010a C801      		movw r24,r16
 965 010c 8058      		subi r24,-128
 966 010e 9109      		sbc r25,__zero_reg__
 967 0110 0E94 0000 		call _ZL12writeToFlashjPhRj
 110:miniboot.c    **** }
 969               	.LM89:
 970 0114 289A      		sbi 0x5,0
 971               	.L35:
 972               	.LBE86:
 973               	.LBE85:
 974               	.LBE82:
 975               	.LBB95:
 976               	.LBB96:
 116:miniboot.c    ****   while (1);
 978               	.LM90:
 979 0116 CF57      		subi r28,lo8(-129)
 980 0118 DF4F      		sbci r29,hi8(-129)
 981 011a E881      		ld r30,Y
 982 011c F981      		ldd r31,Y+1
 983 011e C158      		subi r28,lo8(129)
 984 0120 D040      		sbci r29,hi8(129)
 985 0122 0995      		icall
 986               	.L34:
 987 0124 00C0      		rjmp .L34
 988               	.L26:
 989               	.LBE96:
 990               	.LBE95:
 991               	.LBB97:
 992               	.LBB94:
 136:miniboot.c    ****     eraseApplication();
 137:miniboot.c    ****     writeFlashFromI2C(source_i2c_address_for_program, application_start);
 138:miniboot.c    ****   } else {
 139:miniboot.c    ****     uint16_t address_in_external_eeprom = getWordFromSource(
 140:miniboot.c    ****         source_i2c_address_for_program, application_start_address_byte_offset);
 994               	.LM91:
 995 0126 84E2      		ldi r24,lo8(36)
 996 0128 90E0      		ldi r25,0
 997 012a 0E94 0000 		call _ZL17getWordFromSourcehj.constprop.6
 141:miniboot.c    **** 
 142:miniboot.c    ****     application_start = address_in_external_eeprom >> 8;
 143:miniboot.c    ****     application_start |= static_cast<uint16_t>(static_cast<uint8_t>(address_in_external_eeprom))<<8
 999               	.LM92:
 1000 012e 9827      		eor r25,r24
 1001 0130 8927      		eor r24,r25
 1002 0132 9827      		eor r25,r24
 1003 0134 CF57      		subi r28,lo8(-129)
 1004 0136 DF4F      		sbci r29,hi8(-129)
 1005 0138 9983      		std Y+1,r25
 1006 013a 8883      		st Y,r24
 1007 013c C158      		subi r28,lo8(129)
 1008 013e D040      		sbci r29,hi8(129)
 1009 0140 00C0      		rjmp .L35
 1010               	.LBE94:
 1011               	.LBE97:
 1029               	.Lscope5:
 1031               		.stabd	78,0,0
 1043               		.text
 1045               	.Letext0:
 1046               		.ident	"GCC: (GNU) 5.4.0"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 miniboot.c
     /tmp/ccarZnVc.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccarZnVc.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccarZnVc.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccarZnVc.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccarZnVc.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccarZnVc.s:118    .text:0000000000000000 _ZL12writeToFlashjPhRj
     /tmp/ccarZnVc.s:297    .text:00000000000000ac _ZL8readBytehj.constprop.7
     /tmp/ccarZnVc.s:345    .text:00000000000000d6 _ZL17getWordFromSourcehj.constprop.6
     /tmp/ccarZnVc.s:390    .text:0000000000000104 _ZL7isCrcOkh.constprop.4
     /tmp/ccarZnVc.s:718    .text.startup:0000000000000000 main

UNDEFINED SYMBOLS
_Z9i2c_starth
_Z9i2c_writeh
_Z8i2c_stopv
_Z12i2c_read_ackv
_Z8i2c_initv
__udivmodhi4
