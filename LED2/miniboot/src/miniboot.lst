   1               		.file	"miniboot.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
 113               		.section	.text.startup,"ax",@progbits
 115               	.global	main
 117               	main:
 118               		.stabd	46,0,0
   1:miniboot.c    **** //
   2:miniboot.c    **** //  Fuses :     Ext: 0xFF, Hi: 0xD8, Lo: 0xE2
   3:miniboot.c    **** //
   4:miniboot.c    **** 
   5:miniboot.c    **** #include "crc32.h"
   6:miniboot.c    **** #include "bootloader.h"
   7:miniboot.c    **** #include "eeprom.h"
   8:miniboot.c    **** #include "flash.h"
   9:miniboot.c    **** #include "i2c_communication.h"
  10:miniboot.c    **** #include "init.h"
  11:miniboot.c    **** 
  12:miniboot.c    **** static inline uint16_t getDataStartAddressInSource(const uint8_t i2c_address) {
  13:miniboot.c    ****   return application_byte_offset;
  14:miniboot.c    **** }
  15:miniboot.c    **** 
  16:miniboot.c    **** static inline uint16_t getDataLength(const uint8_t i2c_address) {
  17:miniboot.c    ****   return getWordFromSource(i2c_address, application_length_byte_offset);
  18:miniboot.c    **** }
  19:miniboot.c    **** 
  20:miniboot.c    **** static inline void writeToFlash(const uint16_t address, uint8_t *data,
  21:miniboot.c    ****                                 uint16_t &application_start) {
  22:miniboot.c    **** 
  23:miniboot.c    ****   if (0 == address && 0 == application_start) {
  24:miniboot.c    ****     application_start = static_cast<uint16_t>(data[RESET_VECTOR_ARGUMENT_ADDRESS]) << 8;
  25:miniboot.c    ****     application_start |=
  26:miniboot.c    ****         static_cast<uint8_t>(data[RESET_VECTOR_ARGUMENT_ADDRESS + 1]);
  27:miniboot.c    **** 
  28:miniboot.c    ****     data[RESET_VECTOR] = static_cast<uint8_t>(jmp_instruction);
  29:miniboot.c    ****     data[RESET_VECTOR + 1] = static_cast<uint8_t>(jmp_instruction >> 8);
  30:miniboot.c    **** 
  31:miniboot.c    ****     data[RESET_VECTOR_ARGUMENT_ADDRESS] = static_cast<uint8_t>(
  32:miniboot.c    ****         static_cast<uint16_t>(BOOTLOADER_START_ADDRESS) / 2);
  33:miniboot.c    ****     data[RESET_VECTOR_ARGUMENT_ADDRESS + 1] = static_cast<uint8_t>(
  34:miniboot.c    ****         (static_cast<uint16_t>(BOOTLOADER_START_ADDRESS) / 2) >> 8);
  35:miniboot.c    ****   }
  36:miniboot.c    **** 
  37:miniboot.c    ****   writeToPageBuffer(address, data);
  38:miniboot.c    ****   writePageBufferToFlash(address);
  39:miniboot.c    **** }
  40:miniboot.c    **** 
  41:miniboot.c    **** static inline bool isCrcOk(const uint8_t i2c_address) {
  42:miniboot.c    ****   bool status = false;
  43:miniboot.c    ****   uint32_t crc = 0;
  44:miniboot.c    ****   uint16_t start_address = getDataStartAddressInSource(i2c_address);
  45:miniboot.c    ****   uint16_t length = getDataLength(i2c_address);
  46:miniboot.c    **** 
  47:miniboot.c    ****   uint32_t table[crc_table_size];
  48:miniboot.c    ****   init_table(&table[0]);
  49:miniboot.c    **** 
  50:miniboot.c    ****   for (uint16_t pos = 0; pos < length + 1;
  51:miniboot.c    ****        pos += 2) { // length +1 in case of odd number lengths
  52:miniboot.c    ****     if (pos >= length)
  53:miniboot.c    ****       break;
  54:miniboot.c    **** 
  55:miniboot.c    ****     uint16_t data = getWordFromSource(i2c_address, pos + start_address);
  56:miniboot.c    ****     if (pos == length - 1)
  57:miniboot.c    ****       data &= 0xFF00;
  58:miniboot.c    **** 
  59:miniboot.c    ****     uint8_t to_little_endian[2];
  60:miniboot.c    ****     to_little_endian[0] = static_cast<uint8_t>(data >> 8);
  61:miniboot.c    ****     to_little_endian[1] = static_cast<uint8_t>(data);
  62:miniboot.c    **** 
  63:miniboot.c    ****     crc32(reinterpret_cast<const void *>(&to_little_endian[0]), 2, &table[0],
  64:miniboot.c    ****           &crc);
  65:miniboot.c    **** 
  66:miniboot.c    ****     uint8_t toggle_led_every_x_bytes = 128;
  67:miniboot.c    ****     if (0 == pos % toggle_led_every_x_bytes)
  68:miniboot.c    ****       LED_TOGGLE();
  69:miniboot.c    ****   }
  70:miniboot.c    **** 
  71:miniboot.c    ****   uint32_t expected_crc = static_cast<uint32_t>(getWordFromSource(
  72:miniboot.c    ****                               i2c_address, application_crc_expected_index))
  73:miniboot.c    ****                           << 16;
  74:miniboot.c    ****   expected_crc |= static_cast<uint32_t>(
  75:miniboot.c    ****       getWordFromSource(i2c_address, application_crc_expected_index + 2));
  76:miniboot.c    **** 
  77:miniboot.c    ****   if (crc == expected_crc) {
  78:miniboot.c    ****     status = true;
  79:miniboot.c    ****   }
  80:miniboot.c    ****   return status;
  81:miniboot.c    **** }
  82:miniboot.c    **** 
  83:miniboot.c    **** static inline void writeFlashFromI2C(const uint8_t i2c_address,
  84:miniboot.c    ****                                      uint16_t &application_start) {
  85:miniboot.c    ****   uint16_t start_address = getDataStartAddressInSource(i2c_address);
  86:miniboot.c    ****   uint16_t length = getDataLength(i2c_address);
  87:miniboot.c    ****   uint8_t buf[SPM_PAGESIZE];
  88:miniboot.c    ****   uint16_t writes = 0;
  89:miniboot.c    **** 
  90:miniboot.c    ****   for (uint16_t pos = 0; pos < length; pos += 2) {
  91:miniboot.c    ****     if (pos > 0 && (0 == (pos % SPM_PAGESIZE))) {
  92:miniboot.c    ****       writeToFlash(writes * SPM_PAGESIZE, &buf[0], application_start);
  93:miniboot.c    ****       LED_TOGGLE();
  94:miniboot.c    ****       ++writes;
  95:miniboot.c    ****     }
  96:miniboot.c    ****     uint16_t data = getWordFromSource(i2c_address, pos + start_address);
  97:miniboot.c    ****     buf[pos % SPM_PAGESIZE] = static_cast<uint8_t>(data >> 8);
  98:miniboot.c    ****     buf[(pos + 1) % SPM_PAGESIZE] = static_cast<uint8_t>(data);
  99:miniboot.c    ****   }
 100:miniboot.c    **** 
 101:miniboot.c    ****   for (uint16_t pos = SPM_PAGESIZE -
 102:miniboot.c    ****                       (static_cast<uint16_t>(writes + 1) *
 103:miniboot.c    ****                        static_cast<uint16_t>(SPM_PAGESIZE)) %
 104:miniboot.c    ****                           length;
 105:miniboot.c    ****        pos < SPM_PAGESIZE; ++pos) {
 106:miniboot.c    ****     buf[pos] = 0xFF; // reset contents, since these bytes were not filled in
 107:miniboot.c    ****                      // this page and have value from previous page
 108:miniboot.c    ****   }
 109:miniboot.c    **** 
 110:miniboot.c    ****   writeToFlash(writes * SPM_PAGESIZE, &buf[0], application_start);
 111:miniboot.c    ****   LED_OFF();
 112:miniboot.c    **** }
 113:miniboot.c    **** 
 114:miniboot.c    **** [[ noreturn ]]
 115:miniboot.c    **** static inline void leaveBootloader(uint16_t &application_start) {
 116:miniboot.c    ****   // hold my beer and watch this!
 117:miniboot.c    ****   reinterpret_cast<void (*)(void)>(application_start)();
 118:miniboot.c    ****   while (1);
 119:miniboot.c    **** }
 120:miniboot.c    **** 
 121:miniboot.c    **** static inline bool isReflashNecessary(uint32_t &i2c_application_timestamp) {
 122:miniboot.c    ****   uint32_t current_application_timestamp =
 123:miniboot.c    ****       readLatestApplicationTimestampFromInternalEeprom();
 124:miniboot.c    **** 
 125:miniboot.c    ****   i2c_application_timestamp =
 126:miniboot.c    ****       static_cast<uint32_t>(getWordFromSource(
 127:miniboot.c    ****           source_i2c_address_for_program, timestamp_application_byte_offset))
 128:miniboot.c    ****       << 16;
 129:miniboot.c    ****   i2c_application_timestamp |= static_cast<uint32_t>(getWordFromSource(
 130:miniboot.c    ****       source_i2c_address_for_program, timestamp_application_byte_offset + 2));
 131:miniboot.c    **** 
 132:miniboot.c    ****   if (eeprom_not_programmed == current_application_timestamp)
 133:miniboot.c    ****     return true;
 134:miniboot.c    ****   if (i2c_application_timestamp != current_application_timestamp)
 135:miniboot.c    ****     return true;
 136:miniboot.c    ****   return false;
 137:miniboot.c    **** }
 138:miniboot.c    **** 
 139:miniboot.c    **** int main() {
 120               	.LM0:
 121               	.LFBB1:
 122               	/* prologue: function */
 123               	/* frame size = 0 */
 124               	/* stack size = 0 */
 125               	.L__stack_usage = 0
 126               	.LBB10:
 127               	.LBB11:
 128               	.LBB12:
 129               	.LBB13:
 131               	.Ltext1:
   1:init.h        **** #pragma once
   2:init.h        **** 
   3:init.h        **** #include "I2C-master-lib/i2c_master.h"
   4:init.h        **** #include "io.h"
   5:init.h        **** #include <avr/wdt.h>
   6:init.h        **** 
   7:init.h        **** static inline void initIO() { LED_INIT(); }
   8:init.h        **** 
   9:init.h        **** static inline void disableWatchdog() {
  10:init.h        ****   wdt_reset();
 133               	.LM1:
 134               	/* #APP */
 135               	 ;  10 "init.h" 1
 136 0000 A895      		wdr
 137               	 ;  0 "" 2
  11:init.h        ****   MCUSR = 0;
 139               	.LM2:
 140               	/* #NOAPP */
 141 0002 14BE      		out 0x34,__zero_reg__
  12:init.h        ****   WDTCSR |= (1 << WDCE) | (1 << WDE);
 143               	.LM3:
 144 0004 8091 6000 		lds r24,96
 145 0008 8861      		ori r24,lo8(24)
 146 000a 8093 6000 		sts 96,r24
  13:init.h        ****   WDTCSR = 0;
 148               	.LM4:
 149 000e 1092 6000 		sts 96,__zero_reg__
  14:init.h        ****   asm("cli");
 151               	.LM5:
 152               	/* #APP */
 153               	 ;  14 "init.h" 1
 154 0012 F894      		cli
 155               	 ;  0 "" 2
 156               	/* #NOAPP */
 157               	.LBE13:
 158               	.LBE12:
  15:init.h        **** }
  16:init.h        **** 
  17:init.h        **** static inline void init() {
  18:init.h        ****   disableWatchdog();
  19:init.h        ****   i2c_init();
 160               	.LM6:
 161 0014 0E94 0000 		call _Z8i2c_initv
 162               	.LBB14:
 163               	.LBB15:
   7:init.h        **** 
 165               	.LM7:
 166 0018 2D98      		cbi 0x5,5
 167 001a 80E2      		ldi r24,lo8(32)
 168 001c 84B9      		out 0x4,r24
 169               	.LBE15:
 170               	.LBE14:
 171               	.LBE11:
 172               	.LBE10:
 174               	.Ltext2:
 140:miniboot.c    **** 
 141:miniboot.c    ****   init();
 142:miniboot.c    **** 
 143:miniboot.c    ****   // uint32_t i2c_application_timestamp;
 144:miniboot.c    ****   uint16_t application_start = 0;
 145:miniboot.c    **** 
 146:miniboot.c    ****   // if (isReflashNecessary(i2c_application_timestamp) &&
 147:miniboot.c    ****       // isCrcOk(source_i2c_address_for_program)) {
 148:miniboot.c    ****   LED_ON();
 176               	.LM8:
 177 001e 2D9A      		sbi 0x5,5
 178               	.LBB16:
 179               	.LBB17:
 117:miniboot.c    ****   while (1);
 181               	.LM9:
 182 0020 E0E0      		ldi r30,0
 183 0022 F0E0      		ldi r31,0
 184 0024 0995      		icall
 185               	.L2:
 186 0026 00C0      		rjmp .L2
 187               	.LBE17:
 188               	.LBE16:
 190               	.Lscope1:
 192               		.stabd	78,0,0
 204               		.text
 206               	.Letext0:
 207               		.ident	"GCC: (GNU) 5.4.0"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 miniboot.c
     /tmp/ccoAKoyR.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccoAKoyR.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccoAKoyR.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccoAKoyR.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccoAKoyR.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccoAKoyR.s:117    .text.startup:0000000000000000 main

UNDEFINED SYMBOLS
_Z8i2c_initv
